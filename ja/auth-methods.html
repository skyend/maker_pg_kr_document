<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>認証方式</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="クライアント認証"
HREF="client-authentication.html"><LINK
REL="PREVIOUS"
TITLE="ユーザ名マップ"
HREF="auth-username-maps.html"><LINK
REL="NEXT"
TITLE="認証における問題点"
HREF="client-authentication-problems.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="SECT1"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="ユーザ名マップ"
HREF="auth-username-maps.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="クライアント認証"
HREF="client-authentication.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31532; 19&#31456;クライアント認証</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="クライアント認証"
HREF="client-authentication.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="認証における問題点"
HREF="client-authentication-problems.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AUTH-METHODS"
>19.3. 認証方式</A
></H1
><P
>   以下の小節では、認証方式について詳細に説明します。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-TRUST"
>19.3.1. Trust認証</A
></H2
><P
><TT
CLASS="LITERAL"
>trust</TT
>認証が指定されると<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、サーバに接続できる全ての人に対して
（データベーススーパーユーザさえも）その人が指定する任意のデータベースユーザ名としてのアクセス権限が付与されていると想定します。
当然ながら<TT
CLASS="LITERAL"
>database</TT
>と<TT
CLASS="LITERAL"
>user</TT
>列にある制限は適用されます。
この方式はサーバに接続する際に適切なオペレーティングシステムレベルの保護が掛けられている場合にのみ使用すべきです。
   </P
><P
><TT
CLASS="LITERAL"
>trust</TT
>認証はユーザが1人のみのワークステーション上でローカル接続を行う場合は適切であると同時に非常に便利です。
複数ユーザが存在するマシン上では一般的に適切では<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ありません</I
></SPAN
>。 
とは言っても、ファイルシステムの許可属性を使ってサーバのUnixドメインソケットファイルへのアクセスを制限すれば<TT
CLASS="LITERAL"
>trust</TT
>認証を複数ユーザのマシン上で使用することも可能です。
その方法は、<A
HREF="runtime-config-connection.html"
>&#38917;18.3</A
>に記載されているように<TT
CLASS="VARNAME"
>unix_socket_permissions</TT
>（および<TT
CLASS="VARNAME"
>unix_socket_group</TT
>パラメータの可能性もあります）パラメータを設定します。
もしくは、<TT
CLASS="VARNAME"
>unix_socket_directory</TT
>設定パラメータでソケットファイルをそれに相応しく制限されているディレクトリにします。
   </P
><P
>Unixソケット接続を行うただ1つの方法は、ファイルシステムの許可を設定することです。
ローカルのTCP/IP接続は、ファイルシステムにより制限はされていません。
よってローカルでファイルシステムの許可を使用したい場合は<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>から
<TT
CLASS="LITERAL"
>host ... 127.0.0.1 ...</TT
>の行を削除するか、<TT
CLASS="LITERAL"
>trust</TT
>認証とは異なる方法に変更する必要があります。
   </P
><P
>TCP/IP接続における<TT
CLASS="LITERAL"
>trust</TT
>認証は、<TT
CLASS="LITERAL"
>trust</TT
>を指定する<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>の行によってサーバに接続を許可される全てのマシン上の全てのユーザを信用（trust）できる場合にのみ相応しいものです。
<SPAN
CLASS="SYSTEMITEM"
>ローカルホスト</SPAN
>（127.0.0.1）以外からのTCP/IP接続に<TT
CLASS="LITERAL"
>trust</TT
>認証を用いる理由はほとんど見当たりません。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PASSWORD"
>19.3.2. パスワード認証</A
></H2
><P
>パスワードをベースにした認証方式には <TT
CLASS="LITERAL"
>md5</TT
>および<TT
CLASS="LITERAL"
>password</TT
>があります。 
これらの方式はパスワードが接続間でどのように送信されるか（すなわち、それぞれMD5-hashed、平文）を別にすれば似たような動作をします。
   </P
><P
>もしパスワード<SPAN
CLASS="QUOTE"
>"盗聴"</SPAN
>攻撃に最大の関心があれば<TT
CLASS="LITERAL"
>md5</TT
>を使うのがよいでしょう。 
可能ならば、平文の<TT
CLASS="LITERAL"
>password</TT
>の使用は常に避けなければなりません。
しかし<TT
CLASS="LITERAL"
>md5</TT
>は<A
HREF="runtime-config-connection.html#GUC-DB-USER-NAMESPACE"
>db_user_namespace</A
>機能といっしょに使用することはできません。
接続がSSL暗号化により保護されているのであれば、<TT
CLASS="LITERAL"
>password</TT
>を安全に使用することができます。
（ただしSSLの使用に依存するという点では、SSL証明書認証を使用した方が良いかもしれません。）
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>データベースパスワードはオペレーティングシステムのユーザパスワードとも別のものです。 
各データベースユーザのパスワードは<TT
CLASS="LITERAL"
>pg_authid</TT
>システムカタログテーブルの中に格納されます。 
<KBD
CLASS="USERINPUT"
>CREATE USER foo WITH PASSWORD 'secret';</KBD
>のように、パスワードはSQLコマンド<A
HREF="sql-createuser.html"
>CREATE USER</A
>と<A
HREF="sql-alteruser.html"
>ALTER USER</A
>を使って管理できます。 
もしユーザに対してパスワードが設定されない場合、格納されるパスワードはNULLとなり、そのユーザのパスワード認証は常に失敗します。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="GSSAPI-AUTH"
>19.3.3. GSSAPI認証</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>は、RFC 2743で定義されている安全な認証のための業界標準のプロトコルです。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、RFC 1964により<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>認証と共に<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>をサポートします。
<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>は、<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>をサポートしているシステムに対して自動認証（シングルサインオン）を提供します。
認証自体は安全ですが、データベース接続を通じて送信されるデータは、<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>が使用されていない場合は平文となります。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>が<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>を使用しているとき、<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>は、
<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>servicename</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
>@<TT
CLASS="REPLACEABLE"
><I
>realm</I
></TT
></TT
>の書式において標準の原則を使用します。
原則についての情報や、どのようにして要求された鍵を設定するのかについては<A
HREF="auth-methods.html#KERBEROS-AUTH"
>&#38917;19.3.5</A
>を参照してください。
   </P
><P
>GSSAPIサポートは、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が構築されたときに使用可能となります。詳細は、<A
HREF="installation.html"
>&#31532;15&#31456;</A
>を参照してください。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>include_realm</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>1</TT
>に設定されている場合は、認証されたユーザプリンシパルからのrealm名が、
ユーザ名マッピング（<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>）で渡されるシステムユーザ名の中に含まれています。
これは複数realmからのユーザを扱う場合に便利です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースの間のマッピングを許可します。詳細は<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>を参照してください。
Kerberosプリンシパルに対しては<TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>、もし<TT
CLASS="LITERAL"
>include_realm</TT
>が
無効になっている場合はマッピングに対して使用されるユーザ名は<TT
CLASS="LITERAL"
>username/hostbased</TT
>、
<TT
CLASS="LITERAL"
>include_realm</TT
>が有効になっている場合は<TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_realm</TT
></DT
><DD
><P
>realmをユーザプリンシパル名に一致するように設定します。もしこのパラメータが設定されている場合は
realmのユーザのみが受け付けられます。もしこれが設定されていない場合は、
どのようなrealmのユーザも接続可能で、ユーザ名マッピングが設定されていれば、どれでも影響を受けます。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SSPI-AUTH"
>19.3.4. SSPI認証</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>は、シングルサインオンで安全な認証を行うための<SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>の技術です。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、<TT
CLASS="LITERAL"
>negotiate</TT
>モードにおいてSSPIを使用します。
これは、可能な場合は<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>を使用し、他の場合については自動的に<SPAN
CLASS="PRODUCTNAME"
>NTLM</SPAN
>を使用することを意味しています。
<SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>認証は、サーバ、クライアントが共に<SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>上もしくは<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>が利用可能な場合はWindowsではないプラットフォームで稼動しているときにのみ動作します。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>認証を使用しているとき、
<SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>は、<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>と同じように動作します。
詳細は<A
HREF="auth-methods.html#GSSAPI-AUTH"
>&#38917;19.3.3</A
>を参照してください。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>include_realm</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>1</TT
>に設定されている場合は、認証されたユーザプリンシパルからのrealm名が、
ユーザ名マッピング（<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>）で渡されるシステムユーザ名の中に含まれています。
これは複数realmからのユーザを扱う場合に便利です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>を参照してください。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_realm</TT
></DT
><DD
><P
>realmをユーザプリンシパル名に一致するように設定します。もしこのパラメータが設定されている場合は
realmのユーザのみが受け付けられます。もしこれが設定されていない場合は、
どのようなrealmのユーザも接続可能で、ユーザ名マッピングが設定されていれば、どれでも影響を受けます。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="KERBEROS-AUTH"
>19.3.5. Kerberos認証</A
></H2
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>ネイティブのKerberos認証は、推奨されず互換性のためのみに使用されるべきです。新規に更新されたインストールは業界標準の<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>認証を使用することを推奨しています。(詳細は<A
HREF="auth-methods.html#GSSAPI-AUTH"
>&#38917;19.3.3</A
>を参照してください)
    </P
></BLOCKQUOTE
></DIV
><P
><SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>は業界標準の安全な認証システムで、公開ネットワークにまたがった分散処理に適しています。 
<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>システムの説明はこの文書の範囲外で、概ねとても（強力ですが）複雑なものと言えます。 
<A
HREF="http://www.nrl.navy.mil/CCS/people/kenh/kerberos-faq.html"
TARGET="_top"
>Kerberos<ACRONYM
CLASS="ACRONYM"
>FAQ</ACRONYM
></A
>あるいは<A
HREF="http://web.mit.edu/kerberos/www/"
TARGET="_top"
>MIT Kerberosページ</A
>が探索を開始するにはお勧めです。 
<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>のソースコード配布物はいくつか存在します。
<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>は安全な認証を提供しますが、ネットワーク越しに渡される問い合わせやデータの暗号化を行いません。
このためには<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>を使用してください。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はKerberosのバージョン5をサポートしています。Kerberos認証のサポートは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>がビルドされた時点で開始されます。
詳細は<A
HREF="installation.html"
>&#31532;15&#31456;</A
>を参照してください。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は通常の Kerberos サービスのように動作します。 
サービスのプリンシパル名は<TT
CLASS="REPLACEABLE"
><I
>servicename/hostname@realm</I
></TT
>です。 
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>servicename</I
></TT
>は<A
HREF="runtime-config-connection.html#GUC-KRB-SRVNAME"
>krb_srvname</A
>設定パラメータを使用したサーバ側によって設定されます。
さらに、クライアント側では<TT
CLASS="LITERAL"
>krbsrvname</TT
>接続パラメータを使用します。（<A
HREF="libpq-connect.html"
>&#38917;31.1</A
>も参照してください。）
インストール時のデフォルト<TT
CLASS="LITERAL"
>postgres</TT
>（ビルド時には<TT
CLASS="LITERAL"
>./configure 7 7with-krb-srvnam=whatever</TT
>を使用しています）は、変更が可能です。
多くの環境では、このパラメータは変更する必要はないでしょう。しかしながら、同一ホスト内で複数の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>をサポートするような場合には、必要となります。
いくつかのKerberosの実装では、異なるサービス名が必要になります。Microsoftアクティブディレクトリではサービス名は（<TT
CLASS="LITERAL"
>POSTGRES</TT
>）のように大文字にする必要があります。
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
>はサーバマシンの完全修飾されたホスト名です。 
サービスプリンシパルのrealmはサーバマシンが提起したrealmです[訳注：プリンシパルとは大雑把に2つのものを指します。1つはサービスを受けるクライアントで、もう1つはサービスを提供するサーバアプリケーションです。どちらも、認証に関してはKerberosのKDCから見るとクライアントになります]。
   </P
><P
>クライアントのプリンシパルは第一の構成要素として<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のデータベースユーザ名を所有しなければなりません。
例えば、<TT
CLASS="REPLACEABLE"
><I
>pgusername/otherstuff@realm</I
></TT
>です。  
もう1つの方法として、プリンシパル名の第一の構成要素からデータベースユーザ名にマップするユーザ名マッピングを使用することもできます。
デフォルトではクライアントのrealmは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>で検査されません。
相互のrealm認証が使用可能になっていてrealmを確認する必要がある場合は、<TT
CLASS="LITERAL"
>krb_realm</TT
>パラメータを使用するか
<TT
CLASS="LITERAL"
>include_realm</TT
>を使用可能にしてrealmを検査するためにユーザ名を使用してください。 
   </P
><P
>サーバ鍵ファイルが<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバアカウントによって読み込み可能（そしてできれば読み込み専用）であることを確認してください
（<A
HREF="postgres-user.html"
>&#38917;17.1</A
>を参照してください）。
鍵ファイルの保存場所は<A
HREF="runtime-config-connection.html#GUC-KRB-SERVER-KEYFILE"
>krb_server_keyfile</A
>設定パラメータで指定されます
デフォルトは、<TT
CLASS="FILENAME"
>/usr/local/pgsql/etc/krb5.keytab</TT
>（もしくはビルド時に<TT
CLASS="VARNAME"
>sysconfdir</TT
>で指定されたディレクトリ）です。
   </P
><P
>keytabファイルはKerberosのソフトウェアによって作成されます。詳細はKerberosのドキュメントを参照してください。
MIT互換のKerberos5実装の例を以下に示します。
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>kadmin% </SAMP
><KBD
CLASS="USERINPUT"
>ank -randkey postgres/server.my.domain.org</KBD
>
<SAMP
CLASS="PROMPT"
>kadmin% </SAMP
><KBD
CLASS="USERINPUT"
>ktadd -k krb5.keytab postgres/server.my.domain.org</KBD
></PRE
><P>
   </P
><P
>データベースに接続しようとしている時要求されるデータベースユーザ名に一致するプリンシパルのチケットを所有しているか確認してください。 
例えば、データベースユーザ名<TT
CLASS="LITERAL"
>fred</TT
>に対し、<TT
CLASS="LITERAL"
>fred@EXAMPLE.COM</TT
>のプリンシパルは接続できるでしょう。
<TT
CLASS="LITERAL"
>fred/users.example.com@EXAMPLE.COM</TT
>のプリンシパルも許可するためには<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>内に記述されているユーザ名マップを使用して下さい。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Apache</SPAN
> Web サーバ上で<A
HREF="http://modauthkerb.sf.net"
TARGET="_top"
><SPAN
CLASS="APPLICATION"
>mod_auth_kerb</SPAN
></A
>と<SPAN
CLASS="APPLICATION"
>mod_perl</SPAN
>を使うのであれば<SPAN
CLASS="APPLICATION"
>mod_perl</SPAN
>スクリプトで<TT
CLASS="LITERAL"
>AuthType KerberosV5SaveCredentials</TT
>が使用可能です。
この方法により追加のパスワードを必要とせず、 Webを通して安全なデータベースアクセスができます。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>を参照してください。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>include_realm</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>1</TT
>に設定されている場合は、認証されたユーザプリンシパルからのrealm名が、
ユーザ名マッピング（<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>）で渡されるシステムユーザ名の中に含まれています。
これは複数realmからのユーザを扱う場合に便利です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_realm</TT
></DT
><DD
><P
>realmをユーザプリンシパル名に一致するように設定します。もしこのパラメータが設定されている場合は
realmのユーザのみが受け付けられます。もしこれが設定されていない場合は、
どのようなrealmのユーザも接続可能で、ユーザ名マッピングが設定されていれば、どれでも影響を受けます。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_server_hostname</TT
></DT
><DD
><P
>サービスプリンシパルのホスト名部分を設定します。これは<TT
CLASS="VARNAME"
>krb_srvname</TT
>と組み合わせて使用されますが、
完結したサービスプリンシパルを生成するために使用されます。つまり以下のようになります。
<TT
CLASS="VARNAME"
>krb_srvname</TT
><TT
CLASS="LITERAL"
>/</TT
><TT
CLASS="VARNAME"
>krb_server_hostname</TT
><TT
CLASS="LITERAL"
>@</TT
>REALM
設定されていない場合は、デフォルトではサーバのホスト名になっています。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-IDENT"
>19.3.6. Identを基にした認証</A
></H2
><P
>ident認証方式は、クライアントのオペレーティングシステムのユーザ名を入手し、それを（オプションのユーザ名マップとともに）許可されているデータベースのユーザ名として使用します。  
クライアントのユーザ名の決定はセキュリティの重大なポイントであり、下記のように接続の形式によって異なる働きをします。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>ident</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>を参照してください。
       </P
></DD
></DL
></DIV
><P>
   </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN30648"
>19.3.6.1. TCP/IP経由のident認証</A
></H3
><P
><SPAN
CLASS="QUOTE"
>"身元特定（Identification）プロトコル"</SPAN
>についてはRFC 1413で説明されています。 
事実上全てのUnix系のオペレーティングシステムの配布には、デフォルトでTCPポート113を監視するidentサーバが付属しています。 
identサーバの基本的な機能は<SPAN
CLASS="QUOTE"
>"どのユーザがポート<TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
>からの接続を開始し、自分のポート<TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>への接続を初期化したのか？"</SPAN
>というような質問に答えることです。 
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は物理的な接続が確立された時に<TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>の両方を認識するので、接続するクライアントのホスト上のidentサーバに応答指令信号を送ることができ、理論的には与えられたどの接続にもオペレーティングシステムユーザを決定できます。
   </P
><P
>この手続きの欠点は、クライアントの正直さに頼るところが大きいということです。 
もしクライアントマシンが信用されない、もしくは危険に晒されている場合、攻撃者はポート113上でほぼどんなプログラムでも実行することができ、どのユーザ名でも好きに選んで返すことができます。 
したがってこの認証方式は、各々のクライアントマシンが厳格な管理下にあり、データベースとシステム管理者が密接に連絡を取り合って動作している、外界から閉ざされたネットワークにのみ適していると言えます。 
言い換えると、identサーバが稼働しているマシンを信用しなければなりません。 
次の警告に注意してください。
    <A
NAME="AEN30659"
></A
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="BLOCKQUOTE"
><TR
><TD
WIDTH="10%"
VALIGN="TOP"
>&nbsp;</TD
><TD
VALIGN="TOP"
><P
>      身元特定プロトコルは、認証、あるいはアクセス管理プロトコルには意図されていません。
     </P
></TD
><TD
WIDTH="10%"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="RIGHT"
VALIGN="TOP"
>--<SPAN
CLASS="ATTRIBUTION"
>RFC 1413</SPAN
></TD
><TD
WIDTH="10%"
>&nbsp;</TD
></TR
></TABLE
>
   </P
><P
>いくつかの身元特定サーバは、ユーザ名を（マシンの管理者のみが知っているキーで）暗号化して返すような非標準のオプションを持っています。
このオプションは、身元特定サーバと<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>とを一緒に使用する場合には、使用しては<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>いけません</I
></SPAN
>。
理由は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、返された文字列を復号化して本当のユーザを決定するための手段を持っていないためです。

   </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN30666"
>19.3.6.2. ローカルソケット経由のident認証</A
></H3
><P
>Unixドメインソケットについて<TT
CLASS="SYMBOL"
>SO_PEERCRED</TT
>要求をサポートしているシステム（現時点では<SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
>、<SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>、<SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
>、<SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
>、<SPAN
CLASS="SYSTEMITEM"
>BSD/OS</SPAN
>、および<SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
>）上では、ローカル接続に対してもident認証を適用できます。 
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、接続されているクライアントのオペレーティングシステムの名称を発見するために<TT
CLASS="SYMBOL"
>SO_PEERCRED</TT
>を使用します。
この場合、ident認証使用による危険はありません。
実際、このようなシステム上のローカル接続では推奨される方法です。
   </P
><P
><TT
CLASS="SYMBOL"
>SO_PEERCRED</TT
>要求のないシステム上ではTCP/IP接続に対してのみident認証が使えます。 
使ってみるには<SPAN
CLASS="SYSTEMITEM"
>localhost</SPAN
>アドレス<SPAN
CLASS="SYSTEMITEM"
>127.0.0.1</SPAN
>を指定してこのアドレスに接続してください。
この方法の信頼性は、ローカルなidentサーバが信頼できる範囲までです。
    </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PEER"
>19.3.7. Peer認証</A
></H2
><P
>peer認証方式はカーネルからクライアント上のオペレーティングシステムのユーザ名を取得し、
それをデータベースユーザ名（オプションのユーザ名マップとともに）として使用することにより動作します。この方法はローカル接続でのみ使用可能です。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>peer</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースのユーザ名のマッピングを許可します。詳細は<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>を参照してください。
       </P
></DD
></DL
></DIV
><P>
   </P
><P
>Peer認証はオペレーティングシステムが、<CODE
CLASS="FUNCTION"
>getpeereid()</CODE
>関数、<TT
CLASS="SYMBOL"
>SO_PEERCRED</TT
>のソケットパラメータ、もしくは同じような仕組みを提供しているときにのみ使用可能です。現状では、<SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
>、<SPAN
CLASS="SYSTEMITEM"
>Mac OS X</SPAN
>を含む<SPAN
CLASS="SYSTEMITEM"
>BSD</SPAN
>系、そして<SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
>に含まれています。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-LDAP"
>19.3.8. LDAP認証</A
></H2
><P
>この認証方式は<TT
CLASS="LITERAL"
>password</TT
>と似ていますが、パスワード確認にLDAPを使用する点が異なります。
LDAPはユーザの名前とパスワードの組み合わせの検証のみに使用されます。
そのため、LDAPを使用して認証を行うようにする前に、ユーザはデータベースに存在しなければなりません。
   </P
><P
>LDAP認証は2つのモードで動作します。1つ目のモードでは
サーバは<TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>suffix</I
></TT
>として区別された名前にバインドします。
一般的に、<TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>パラメータはActive Directory環境での<TT
CLASS="LITERAL"
>cn=</TT
>や<TT
CLASS="REPLACEABLE"
><I
>DOMAIN</I
></TT
><TT
CLASS="LITERAL"
>\</TT
>を特定するために使用されます。
<TT
CLASS="REPLACEABLE"
><I
>suffix</I
></TT
>は、Active Directory環境ではない場合でのDNの残りの部分を特定するために使用されます。
   </P
><P
>2つ目のモードでは、サーバは最初に<TT
CLASS="REPLACEABLE"
><I
>ldapbinduser</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>ldapbinddn</I
></TT
>で指定された、
固定されたユーザ名とパスワードを使用してLDAPディレクトリにバインドします。
それからデータベースにログインしようとしているユーザを検索します。
もしユーザとパスワードが指定されていなかった場合は、ディレクトリに対して匿名でバインドします。
検索は<TT
CLASS="REPLACEABLE"
><I
>ldapbasedn</I
></TT
>のサブツリーまで行われ、<TT
CLASS="REPLACEABLE"
><I
>ldapsearchattribute</I
></TT
>で指定された属性に
正確に一致するかどうかまで行われます。
もし属性が指定されていない場合は、<TT
CLASS="LITERAL"
>uid</TT
>属性が使用されます。
この検索において、一度ユーザが見つかるとサーバは切断して、クライアントで指定されたパスワードを使用して
このユーザとして再度ディレクトリにバインドします。これはログインが正しいかどうかを確かめるためです。
この方法は、ユーザオブジェクトがディレクトリに配置されている場合に、かなりの柔軟性があります。
しかし、LDAPサーバへの2つの分離した接続が作成されます。
   </P
><P
>次の設定オプションはLDAPのためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ldapserver</TT
></DT
><DD
><P
>接続するLDAPサーバの名称もしくはIPアドレスの名称。空白で区切ることで複数のサーバを指定できます。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapport</TT
></DT
><DD
><P
>LDAPサーバに接続するためのポート番号。もしポートが指定されていない場合は
LDAPライブラリ内のデフォルトポート設定が使用されます。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldaptls</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>1</TT
>に設定すると、PostgreSQLとLDAPサーバ間の接続にTLSによる暗号化を使用します。
これはLDAPサーバへのトラフィックのみを暗号化することに注意してください。&mdash;
クライアントへの接続はSSLを使用しない限り暗号化されません。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapprefix</TT
></DT
><DD
><P
>単純なバインド認証を行う場合のDNを生成する際にユーザ名の前に追加する文字列
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapsuffix</TT
></DT
><DD
><P
>単純なバインド認証を行う場合のDNを生成する際にユーザ名の前に追加する文字列
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapbasedn</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合のユーザ名がログインするための検索を始めるためのDN
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapbinddn</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合のディレクトリと検索をバインドするためのユーザのDN
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapbindpasswd</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合のディレクトリと検索をバインドするためのユーザのパスワード
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapsearchattribute</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合の検索時のユーザ名に対して一致させる属性
        </P
></DD
></DL
></DIV
><P>
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>LDAPは、DNの異なる部分を分けるのにしばしばカンマと空白を使用します。そのため
LDAPオプションを設定する際に2重引用符パラメータ値を使用する必要があります。
例を以下に示します。
</P><PRE
CLASS="PROGRAMLISTING"
>ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"</PRE
><P>
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-RADIUS"
>19.3.9. RADIUS authentication</A
></H2
><P
>この認証方法は、RADIUSをパスワード検証として使用するという点を除いて<TT
CLASS="LITERAL"
>password</TT
>と似た動作をします。
RADIUSはユーザ名/パスワードの組のみを検証するために使用されます。
よってユーザはRADIUSが認証に使用される以前にデータベースにすでに存在していなければいけません。
   </P
><P
>RADIUS認証を使用する場合に、設定されたRADIUSサーバにアクセスリクエストメッセージが送信されます。
このリクエストは<TT
CLASS="LITERAL"
>Authenticate Only</TT
>の形式になり、<TT
CLASS="LITERAL"
>ユーザ名</TT
>, （暗号化された）<TT
CLASS="LITERAL"
>パスワード</TT
>、<TT
CLASS="LITERAL"
>NAS識別子</TT
>を含んでいます。
リクエストはサーバと共有している秘密を用いて暗号化されます。
RADIUSサーバは、このサーバに対して<TT
CLASS="LITERAL"
>Access Accept</TT
>もしくは<TT
CLASS="LITERAL"
>Access Reject</TT
>を返します。
RADIUSアカウントのサポートはありません。
   </P
><P
>RADIUSのために次の設定オプションがサポートされています。
     <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>radiusserver</TT
></DT
><DD
><P
>接続するRADIUSサーバの名称もしくはIPアドレス。このパラメータは必要です。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>radiussecret</TT
></DT
><DD
><P
>RADIUSサーバとのやり取りに使用される共有の秘密。これはPostgreSQLとRADIUSサーバにおいて
厳密に同じ値にする必要があります。少なくとも16文字以上の文字列が推奨されます。このパラメータは必要です。
         </P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>をサポートする場合に暗号化ベクター使用するときのみ
強力になります。他の場合にはRADIUSサーバへの伝送は難読化されているだけで、安全ではなく
必要な場合は外部のセキュリティ方法を適用すべきです。
         </P
></BLOCKQUOTE
></DIV
><P>
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>radiusport</TT
></DT
><DD
><P
>接続するRADIUSサーバのポート番号。もしポート番号が指定されていない場合は、デフォルトポートである<TT
CLASS="LITERAL"
>1812</TT
>が使用されます。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>radiusidentifier</TT
></DT
><DD
><P
>RADIUSリクエスト内で<TT
CLASS="LITERAL"
>NAS Identifier</TT
>として使用されている文字列。
ユーザがどのデータベースユーザに対して認証しようとしているか、RADIUSサーバにおいてポリシーを一致させるために何が使用されるか、
を識別するために、このパラメータは2番目のパラメータとして使用されます。
もし識別子が指定されていない場合は、デフォルトの<TT
CLASS="LITERAL"
>postgresql</TT
>が使用されます。
        </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-CERT"
>19.3.10. 証明書認証</A
></H2
><P
>この認証方法は、認証のためにSSLクライアント証明書を使用します。
よってこの方法は、SSL接続を使用します。
この認証方法を使用する際は、サーバはクライアントが有効な証明書を提供することを要求します。
パスワードのプロンプトはクライアントに送信されません。
証明書の<TT
CLASS="LITERAL"
>cn</TT
>（Common Name）属性は、要求されたデータベースユーザ名と比較されます。
もしそれらが一致した場合はログインが許可されます。ユーザ名マッピングは、<TT
CLASS="LITERAL"
>cn</TT
>がデータベースユーザ名と異なるものであることを許可するために使用されます。
   </P
><P
>次の設定オプションはSSL証明書認証のためにサポートされています。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<A
HREF="auth-username-maps.html"
>&#38917;19.2</A
>を参照してください。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PAM"
>19.3.11. PAM認証</A
></H2
><P
>この認証方式は認証機構としてPAM（Pluggable Authentication Modules）を使用することを除いて<I
CLASS="FIRSTTERM"
>password</I
>のように動作します。 
デフォルトのPAMサービス名は<TT
CLASS="LITERAL"
>postgresql</TT
>です。 
PAMはユーザ名/パスワードの組を承認するためだけに使用されます。
PAMについての詳細は<A
HREF="http://www.kernel.org/pub/linux/libs/pam/"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>Linux-PAM</SPAN
>ページ</A
>と<A
HREF="http://www.sun.com/software/solaris/pam/"
TARGET="_top"
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
> PAMページ</A
>を読んでください。
   </P
><P
>次の設定オプションはPAMのためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>pamservice</TT
></DT
><DD
><P
>PAMサービス名。
       </P
></DD
></DL
></DIV
><P>
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
>PAMが<TT
CLASS="FILENAME"
>/etc/shadow</TT
>を読み取るように設定されている場合は、PostgreSQLがルートユーザで起動されていないため、認証は失敗するでしょう。
しかしPAMがLDAPや他の認証方法を使用するように設定されている場合は、これは問題ではありません。
    </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="auth-username-maps.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="client-authentication-problems.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ユーザ名マップ</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>認証における問題点</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
