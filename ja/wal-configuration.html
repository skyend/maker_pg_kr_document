<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>WALの設定</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="信頼性とログ先行書き込み"
HREF="wal.html"><LINK
REL="PREVIOUS"
TITLE="非同期コミット"
HREF="wal-async-commit.html"><LINK
REL="NEXT"
TITLE="WALの内部"
HREF="wal-internals.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="SECT1"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="非同期コミット"
HREF="wal-async-commit.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="信頼性とログ先行書き込み"
HREF="wal.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31532; 29&#31456;信頼性とログ先行書き込み</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="信頼性とログ先行書き込み"
HREF="wal.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="WALの内部"
HREF="wal-internals.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WAL-CONFIGURATION"
>29.4. <ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>の設定</A
></H1
><P
>データベースの性能に影響するような<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>に関連した設定パラメータが複数あります。
本節では、その使い方を説明します。
サーバ設定パラメータの設定方法についての詳細は<A
HREF="runtime-config.html"
>&#31532;18&#31456;</A
>を参照してください。
  </P
><P
><I
CLASS="FIRSTTERM"
>チェックポイント</I
>は、一連のトランザクションにおいて、それ以前に書き出された全ての情報でヒープとインデックスファイルが更新されていることが保証されている時点を指します。

チェックポイントでは、全てのダーティデータページがディスクに吐き出され、特別なチェックポイントレコードがログファイルに書き込まれます。(これらのの変更は以前に<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>ファイルへ書き出されています。)
クラッシュした時、クラッシュからの復旧処理は最後のチェックポイントレコードを見つけ、ログの中でどのレコード（これはredoレコードと呼ばれています）から復旧処理がREDOログ操作を開始すべきかを決定します。
このチェックポイント以前になされたデータの変更は、すでにディスク上にあることが保証されています。
従って、チェックポイント後、redoレコード内のそのチェックポイント以前のログセグメントは不要となり、再利用または削除することができます
（<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>アーカイブが行われる場合、このログセグメントは削除もしくは再利用される前に保存されなければなりません）。
  </P
><P
>チェックポイント処理は、全てのダーティデータページをディスクへ書き出すため、大きなI/O負荷を発生させます。このため、チェックポイント処理は利用するI/O帯域を絞り込むようにしており、チェックポイントの開始から次のチェックポイントの開始前までI/Oの発生が続きます。これは、チェックポイント処理中の性能劣化を極力抑える効果があります。
  </P
><P
>サーバのバックグラウンドライタプロセスは自動的にチェックポイントを頻繁に実行します。
<A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-SEGMENTS"
>checkpoint_segments</A
>ログセグメント数に達するか、または<A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-TIMEOUT"
>checkpoint_timeout</A
>秒が経過するか、どちらかの条件が満たされるとチェックポイントが作成されます。
デフォルトの設定では、それぞれ3セグメントと300秒(5分)となっています。
また、<TT
CLASS="COMMAND"
>CHECKPOINT</TT
> SQLコマンドで強制的にチェックポイントを作成することもできます。
  </P
><P
><TT
CLASS="VARNAME"
>checkpoint_segments</TT
>、<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>、またはその両者を減少させると、チェックポイントはより頻繁に行われます。
これにより、（再処理に要する時間がより少なくなりますので）クラッシュ後の修復は高速になります。
しかし、より頻繁に行われるようになる、変更されたデータページの吐き出しにより増大するコストとバランスを考えなければなりません。
<A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>が設定されている（デフォルトです）場合、他に考慮しなければならない点があります。
データページの一貫性を保証するために、各チェックポイント後の最初に変更されるデータページは、そのページ全体の内容がログに保存されることになります。
このような場合、チェックポイントの間隔を少なくすることは、WALログへの出力を増加させ、間隔を短くする目的の一部を無意味にします。 
また、確実により多くのディスクI/Oが発生します。
  </P
><P
>チェックポイントはかなり高価なものです。
1番の理由は、この処理は現時点の全てのダーティバッファを書き出す必要があること、2番目の理由は、上記のようにその後に余計なWALの書き込みが発生することです。
そのため、チェックポイント用のパラメータを高くし、チェックポイントがあまりにも頻発することがないようにすることを勧めます。
簡単なチェックポイント用のパラメータの健全性検査として、<A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-WARNING"
>checkpoint_warning</A
>パラメータを設定することができます。
チェックポイントの発生間隔が<TT
CLASS="VARNAME"
>checkpoint_warning</TT
>秒未満の場合、<TT
CLASS="VARNAME"
>checkpoint_segments</TT
>の増加を勧めるメッセージがサーバのログに出力されます。
このメッセージが稀に現れたとしても問題にはなりませんが、頻出するようであれば、チェックポイントの制御パラメータを増加させるべきです。
<TT
CLASS="VARNAME"
>checkpoint_segments</TT
>を十分高く設定していないと、大規模な<TT
CLASS="COMMAND"
>COPY</TT
>転送などのまとまった操作でこうした警告が多く発生するかもしれません。
  </P
><P
>ページ書き出しの集中による入出力システムの溢れを防ぐために、チェックポイント期間のダーティバッファの書き出しは一定の期間に分散されます。
この期間は<A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET"
>checkpoint_completion_target</A
>により制御され、チェックポイント間隔の割合として指定されます。
I/Oの割合は、チェックポイントの起動時から<TT
CLASS="VARNAME"
>checkpoint_segments</TT
> WALセグメントが消費された時、あるいは、指定した<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>秒が経過した時、このどちらかが発生するとすぐに、チェックポイントが完了するように調整されます。
デフォルトの0.5という値では、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、次のチェックポイントが始まるまでのおよそ半分の時間で各チェックポイントが完了するものと想定できることになります。
通常の操作においてほぼ最大のI/Oスループットに近いようなシステムでは、チェックポイントにおけるI/O負荷を減らすために<TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
>を増やすことを勧めます。
この欠点は、延長されたチェックポイントがリカバリ時に影響をあたえることです。
リカバリ時に使用できるように、より多くのWALセグメントを保持する必要があるためです。
<TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
>を最大の1.0に設定することもできますが、より低く抑えること（おそらく最大で0.9）が最善です。
チェックポイントには、ダーティバッファを書き出す以外の活動も含まれているからです。
1.0という設定は、ある時点でチェックポイントが完了しなくなるという結果に陥ります。
これは必要なWALセグメント数が想定以上に変動することになり、性能の劣化が発生することになります。
  </P
><P
>WALセグメントファイルは常に少なくとも1つあり、また、通常は(2 + <TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
>) * <TT
CLASS="VARNAME"
>checkpoint_segments</TT
> + 1、もしくは<TT
CLASS="VARNAME"
>checkpoint_segments</TT
> + <A
HREF="runtime-config-replication.html#GUC-WAL-KEEP-SEGMENTS"
>wal_keep_segments</A
> + 1より多くはありません。
各セグメントファイルは通常16メガバイト（このサイズはサーバのコンパイル時に変更可能）です。
このことから、<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>で必要とされる領域を推定できます。
普通、古いセグメントファイルが不要になった時、それらは再利用（将来順番に使われるセグメントとなるように名前が変更）されます。
短時間のログ出力のピークのためにセグメントファイル数が3×<TT
CLASS="VARNAME"
>checkpoint_segments</TT
> + 1を超えた場合、システムは、この上限以下になるまで、不要になったセグメントファイルを再利用せずに、削除します。
  </P
><P
>  アーカイブからのリカバリもしくはスタンバイモードにおいて、サーバでは定期的に通常運用でのチェックポイント処理と似た<I
CLASS="FIRSTTERM"
>リスタートポイント</I
>処理を行います。これは、すでに再生されたWALを再度読み込む必要がないよう、ディスクに現在の状態を強制的に書き込み、<TT
CLASS="FILENAME"
>pg_control</TT
>ファイルを更新します。また<TT
CLASS="FILENAME"
>pg_xlog</TT
>中の古いログセグメントを再利用できるようにします。リスタートポイント処理は、少なくとも1回のチェックポイントが再生されており、最後のリスタートポイント処理から<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>秒が経過した際に発生します。スタンバイモードでは、最後のリスタートポイント処理時から<TT
CLASS="VARNAME"
>checkpoint_segments</TT
>分のログセグメントが再生され、かつ少なくとも1回のチェックポイントが再生されていた場合にもリスタートポイント処理が走ります。リスタートポイント処理はチェックポイントが記録された時にしか実施されないので、マスタ側のチェックポイント処理よりも発生頻度は低いでしょう。
  </P
><P
>よく使われる2つの内部用<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>関数があります。
<CODE
CLASS="FUNCTION"
>LogInsert</CODE
>と<CODE
CLASS="FUNCTION"
>LogFlush</CODE
>です。
<CODE
CLASS="FUNCTION"
>LogInsert</CODE
>は共有メモリ上の<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>バッファに新しいレコードを挿入します。
新しいレコードを挿入する余地がない時は、<CODE
CLASS="FUNCTION"
>LogInsert</CODE
>は、満杯になった<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>バッファを書き込み（カーネルキャッシュに移動）しなければいけません。
これは望ましいことではありません。 
なぜなら、データベースへの低レベルの変更（例えば行の挿入）の度に<CODE
CLASS="FUNCTION"
>LogInsert</CODE
>が呼ばれますが、そのような場合には変更を受けたページに対して排他ロックがかかっており、それゆえこの操作は可能な限り高速に実行されなければなりません。
さらに悪いことには、<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>バッファへの書き込みの際に、さらに時間がかかる、強制的な新しいログセグメントの生成が必要となるかもしれません。
通常、<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>の書き込み、吐き出しは<CODE
CLASS="FUNCTION"
>LogFlush</CODE
>要求で実施されます。 
これはたいていの場合、トランザクションコミットの際に永続的な記憶領域にトランザクションレコードが吐き出されることを保証するために行われます。
ログ出力が大量に行われるシステムでは、<CODE
CLASS="FUNCTION"
>LogInsert</CODE
>によって必要となる書き込みを防ぐほどには<CODE
CLASS="FUNCTION"
>LogFlush</CODE
>要求が頻繁に起こらないかもしれません。
そういうシステムでは、<A
HREF="runtime-config-wal.html#GUC-WAL-BUFFERS"
>wal_buffers</A
>設定パラメータを変更して<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>バッファの数を増やしてください。
デフォルトの<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>バッファの数は8です。 
この数を増やすと共有メモリの使用量に影響があります。
<A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>が設定され、かつ、システムが高負荷状態である場合、この値を高くすることで、各チェックポイントの直後の応答時間を滑らかにすることができます。
  </P
><P
><A
HREF="runtime-config-wal.html#GUC-COMMIT-DELAY"
>commit_delay</A
>パラメータは、<CODE
CLASS="FUNCTION"
>LogInsert</CODE
>がコミットレコードをログに書き込んでから<CODE
CLASS="FUNCTION"
>LogFlush</CODE
>が行われるまでの間にサーバプロセスが何マイクロ秒休止するかを定義します。
この遅延により、他のサーバプロセスがコミットレコードをログに書き込んだ後、それら全てのログレコードを1回のログ同期で吐き出すことができます。
<A
HREF="runtime-config-wal.html#GUC-FSYNC"
>fsync</A
>が無効な場合や、<A
HREF="runtime-config-wal.html#GUC-COMMIT-SIBLINGS"
>commit_siblings</A
>よりも少ない数のセッションしか現在アクティブなトランザクションに存在しない場合は、休止しません。 
この処理により、すぐにコミットしそうなセッションがない時でも休止してしまうことを防ぐことができます。
たいていのプラットフォームでは、休止の最小単位は10ミリ秒であることに注意してください。 
ですから、1マイクロ秒から10,000マイクロ秒までの間での0以外の<TT
CLASS="VARNAME"
>commit_delay</TT
>の設定は、同じ効果になるでしょう。
これらのパラメータの適切な値はまだ明確ではありません。 実験が必要です。
  </P
><P
><A
HREF="runtime-config-wal.html#GUC-WAL-SYNC-METHOD"
>wal_sync_method</A
>パラメータは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>がカーネルに対して<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>更新のディスクへの書き込みを要求する方法を決定します。
<TT
CLASS="LITERAL"
>fsync_writethrough</TT
>を除き、どういう設定でも信頼性は同じはずです。<TT
CLASS="LITERAL"
>fsync_writethrough</TT
>は他のオプションがそうしないときでも、時々ディスクキャッシュの書き出しを強制することができます。
しかしながら、プラットフォームによってどれが一番速いのかがまったく違います。
<A
HREF="pgtestfsync.html"
>pg_test_fsync</A
>モジュールを使ってオプションの速度テストを行うことができます。
ちなみに、このパラメータは<TT
CLASS="VARNAME"
>fsync</TT
>が無効になっている場合は役に立ちません。

  </P
><P
><A
HREF="runtime-config-developer.html#GUC-WAL-DEBUG"
>wal_debug</A
>設定パラメータを有効にすることで、<CODE
CLASS="FUNCTION"
>LogInsert</CODE
>と<CODE
CLASS="FUNCTION"
>LogFlush</CODE
>という<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>呼び出しは毎回サーバログにログが残ります
（このパラメータをサポートするように<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>をコンパイルする必要があります）。
将来このオプションはより一般的な機構に置き換わる可能性があります。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="wal-async-commit.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="wal-internals.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>非同期コミット</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="wal.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>WALの内部</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
