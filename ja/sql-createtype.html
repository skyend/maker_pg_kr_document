<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE TYPE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE TRIGGER"
HREF="sql-createtrigger.html"><LINK
REL="NEXT"
TITLE="CREATE USER"
HREF="sql-createuser.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="REFENTRY"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE TRIGGER"
HREF="sql-createtrigger.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE TRIGGER"
HREF="sql-createtrigger.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE USER"
HREF="sql-createuser.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE USER"
HREF="sql-createuser.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATETYPE"
></A
>CREATE TYPE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN68913"
></A
><H2
>&#21517;&#21069;</H2
>CREATE TYPE&nbsp;--&nbsp;新しいデータ型を定義する</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN68918"
></A
><H2
>&#27010;&#35201;</H2
><PRE
CLASS="SYNOPSIS"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> AS
    ( [ <TT
CLASS="REPLACEABLE"
><I
>attribute_name</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [, ... ] ] )

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> AS ENUM
    ( [ '<TT
CLASS="REPLACEABLE"
><I
>label</I
></TT
>' [, ... ] ] )

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> (
    INPUT = <TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
>,
    OUTPUT = <TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
>
    [ , RECEIVE = <TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
> ]
    [ , SEND = <TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
> ]
    [ , TYPMOD_IN = <TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
> ]
    [ , TYPMOD_OUT = <TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
> ]
    [ , ANALYZE = <TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
> ]
    [ , INTERNALLENGTH = { <TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
> ]
    [ , STORAGE = <TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
> ]
    [ , LIKE = <TT
CLASS="REPLACEABLE"
><I
>like_type</I
></TT
> ]
    [ , CATEGORY = <TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
> ]
    [ , PREFERRED = <TT
CLASS="REPLACEABLE"
><I
>preferred</I
></TT
> ]
    [ , DEFAULT = <TT
CLASS="REPLACEABLE"
><I
>default</I
></TT
> ]
    [ , ELEMENT = <TT
CLASS="REPLACEABLE"
><I
>element</I
></TT
> ]
    [ , DELIMITER = <TT
CLASS="REPLACEABLE"
><I
>delimiter</I
></TT
> ]
    [ , COLLATABLE = <TT
CLASS="REPLACEABLE"
><I
>collatable</I
></TT
> ]
)

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN68945"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>は、現在のデータベースで使用できる新しいデータ型を登録します。
型を定義したユーザがその所有者となります。
  </P
><P
>スキーマ名が与えられている場合、型は指定されたスキーマで作成されます。
スキーマ名がなければ、その型は現在のスキーマで作成されます。
型名は、同じスキーマにある既存の型もしくはドメインとは、異なる名前にする必要があります
（さらに、テーブルはデータ型と関連しているため、データ型名は同じスキーマのテーブル名とも競合しないようにしてください）。
  </P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN68950"
></A
><H3
>複合型</H3
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>の最初の構文を使用すると、複合型を作成できます。
複合型は、列名およびデータ型のリストにより指定されます。
データ型の照合順序が設定可能である場合、属性の照合順序も指定することができます。
複合型は本質的にはテーブルの行型と同じです。
しかし、型を定義するだけであれば、<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>を使用することで、実際のテーブルを作成する必要をなくすことができます。
スタンドアロンの複合型は、例えば関数の引数や戻り値の型として使用すると有用です。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATETYPE-ENUM"
></A
><H3
>列挙型</H3
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>の2つ目の構文を使用すると、<A
HREF="datatype-enum.html"
>&#38917;8.7</A
>で説明する列挙型（enum）を作成します。
列挙型は、1つ以上の引用符付きのラベルのリストを取ります。
ラベルは<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>（<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を標準で構築した場合は64）バイトよりも少ない長さでなければなりません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN68962"
></A
><H3
>基本型</H3
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>の3つ目の構文を使用すると、基本型（スカラ型）を新しく作成できます。
新しい基本型を作成するにはスーパーユーザでなければなりません。
（エラーがある型定義が混乱を招き、サーバがクラッシュすることすらあるため、この制限がなされました。）
  </P
><P
>パラメータは、上述の順番である必要はなく、任意の順番で指定することができます。
型を定義する前に、（<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>を用いて）2つ以上の関数を登録しておく必要があります。
サポート関数である<TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
>は必須です。
<TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
>関数、<TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
>関数、<TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>関数、<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>関数、および<TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
>関数は省略可能です。
通常、これらの関数は、C言語やその他の低レベル言語で作成されなければなりません。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
>は、型のテキストによる外部表現を内部表現形式に変換するものであり、その型用に定義される演算子や関数で使用されます。
<TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
>はこの逆の変換を行うものです。
入力関数は、1つの<TT
CLASS="TYPE"
>cstring</TT
>型の引数、あるいは、<TT
CLASS="TYPE"
>cstring</TT
>型、<TT
CLASS="TYPE"
>oid</TT
>型、<TT
CLASS="TYPE"
>integer</TT
>型という3つの引数を取るように宣言されます。
最初の引数にはC文字列の入力テキスト、2番目には型自体のOID（配列型の場合は例外で要素の型のOIDとなります）、3番目は、判明していれば対象列の<TT
CLASS="LITERAL"
>typmod</TT
>を渡します
（不明な場合は-1を渡します）。
この入力関数では、データ型自身の値を返さなければなりません。 
通常入力関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でも関数はNULLを返さなければなりません。
さもなくばエラーになります。
（こうした状況はほとんどの場合、ドメイン入力関数をサポートすることを意図しています。ドメイン入力関数ではNULL入力を拒絶する可能性があります。）
出力関数は、新しいデータ型の引数を1つ取るように宣言しなければなりません。
出力関数は、<TT
CLASS="TYPE"
>cstring</TT
>型を返さなければなりません。
出力関数はNULL値に対して呼び出されることはありません。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
>では、型のバイナリによる外部表現を内部表現に変換します。この関数は省略可能です。
この関数が与えられない場合、この型ではバイナリ入力を行うことができません。
バイナリ表現の方法は、適度な移植性を保ちつつ、内部表現への変換コストが小さくなるよう選択すべきです
（例えば標準の整数データ型は、外部バイナリ表現としてはネットワークバイトオーダを使用し、内部表現ではマシン固有のバイトオーダを使用します）。
この受信関数では、値が有効かどうかを判定するための適切な検査を行わなければなりません。
受信関数は、<TT
CLASS="TYPE"
>internal</TT
>型の引数1つ、または、<TT
CLASS="TYPE"
>internal</TT
>型と<TT
CLASS="TYPE"
>oid</TT
>、<TT
CLASS="TYPE"
>integer</TT
>型の3つの引数を取るように宣言されます。
最初の引数は受信したバイト文字列を保持する<TT
CLASS="TYPE"
>StringInfo</TT
>バッファへのポインタ、省略可能な引数は、入力関数の説明と同じです。
そして、データ型自体の値を返す必要があります。
通常受信関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でも関数はNULLを返さなければなりません。
さもなくばエラーになります。
（こうした状況はほとんどの場合、ドメイン受信関数をサポートすることを意図しています。ドメイン受信関数ではNULL入力を拒絶する可能性があります。）
同様に、<TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
>は、内部表現からバイナリによる外部表現に変換します。この関数も省略可能です。
この関数が与えられない場合、この型ではバイナリ出力を行うことができません。
この送信関数は、新しいデータ型の引数1つを取るように宣言しなければなりません。
送信関数は<TT
CLASS="TYPE"
>bytea</TT
>型を返さなければなりません。
送信関数はNULL値に対して呼び出されません。
  </P
><P
>ここで、新しいデータ型を作成する前に入力関数と出力関数を作成する必要があるのに、どのようにしてそれらの関数で新しいデータ型を戻り値や入力として宣言できるのか、疑問に思うかもしれません。
その答えは、まず型が最初に<I
CLASS="FIRSTTERM"
>シェル型</I
>として定義されます。
この型はプレースホルダ型であり、名称と所有者以外の属性を持ちません。
これは、他にパラメータを持たない<TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
>コマンドを発行することで行われます。
この後、入出力関数をこのシェル型を参照するように定義することができます。
最後に完全な定義を持った<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>によって、シェル型の項目が完全かつ有効な型定義に置き換わり、新しい型を普通に使用することができるようになります。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>は省略可能ですが、型が修正子をサポートする場合は必要です。
修正子とは、<TT
CLASS="LITERAL"
>char(5)</TT
>や<TT
CLASS="LITERAL"
>numeric(30,2)</TT
>などの省略可能な型宣言に付与される制約です。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、ユーザ定義型が1つ以上の整数定数または識別子を修正子として取ることができます。
しかし、この情報はシステムカタログに格納される時に単一非負の整数にまとめられるものでなければなりません。
<TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>には、<TT
CLASS="TYPE"
>cstring</TT
>型配列の形で宣言された修正子が渡されます。
その値について妥当性を検査しなければなりません（不当な場合はエラーとします）。
そして、正しい場合は、<SPAN
CLASS="QUOTE"
>"typmod"</SPAN
>列として格納される、単一非負の<TT
CLASS="TYPE"
>integer</TT
>値を返さなければなりません。
型が<TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>を持たない場合、型修正子は拒否されます。
<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>は内部的な整数typmod値をユーザ側の表示に合わせて変換します。
この関数は型名に付与する正確な文字列となる<TT
CLASS="TYPE"
>cstring</TT
>値を返さなければなりません。
たとえば<TT
CLASS="TYPE"
>numeric</TT
>用の関数では<TT
CLASS="LITERAL"
>(30,2)</TT
>を返すかもしれません。
デフォルトの表示用書式が保管されたtypmod整数値を括弧で括ったものと一致している場合は、<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>を省略することができます。

  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
>は、このデータ型の列に対する、型固有の統計情報の収集を行います。この関数は省略可能です。
デフォルトでは、その型用のデフォルトのB-tree演算子クラスがあれば、<TT
CLASS="COMMAND"
>ANALYZE</TT
>は型の<SPAN
CLASS="QUOTE"
>"等価"</SPAN
>演算子と<SPAN
CLASS="QUOTE"
>"小なり"</SPAN
>演算子を使用して統計情報を集めようと試みます。
非スカラ型には、この振舞いはあまり適していません。
そのため、独自の解析関数を指定すると、この振舞いを上書きすることができます。
この解析関数は、<TT
CLASS="TYPE"
>internal</TT
>型の引数を1つ取り、戻り値として<TT
CLASS="TYPE"
>boolean</TT
>を返すように宣言する必要があります。
解析関数用のAPIの詳細は、<TT
CLASS="FILENAME"
>src/include/commands/vacuum.h</TT
>にあります。
  </P
><P
>新しい型の内部表現の詳細を理解しなければならないのは、これらのI/O関数とその型に関連して動作するユーザ定義の関数のみですが、内部表現には、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に対し宣言しなければならない複数の属性値があります。
属性の中で最も重要なものは<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>です。
基本データ型は、<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>に正の整数を指定して固定長として作成するだけでなく、<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>に<TT
CLASS="LITERAL"
>VARIABLE</TT
>と設定し可変長として作成することもできます
（内部的には、これは<TT
CLASS="LITERAL"
>typlen</TT
>を-1に設定することで表現されます）。  
全ての可変長型の内部表現は、型の値の全長を示す4バイトの整数値から始まらなければなりません。

  </P
><P
><TT
CLASS="OPTION"
>PASSEDBYVALUE</TT
>フラグは、このデータ型の値が参照ではなく値によって渡されることを示します。このフラグは省略可能です。
<TT
CLASS="TYPE"
>Datum</TT
>型のサイズ（ほとんどのマシンでは4バイトだが、まれに8バイト）よりも長い内部表現の型は値で渡すことができません。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
>パラメータは、そのデータ型の格納の際に整列が必要であることを示します。
設定可能な値は、1、2、4、8バイト境界での整列と同じです。
可変長型の位置配置は最低でも4を持たなければならないことに注意してください。
最初の要素として<TT
CLASS="TYPE"
>int4</TT
>を持たなければならないからです。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>パラメータを使用することで、可変長データ型を格納する際の戦略を選択することができます
（固定長の型には<TT
CLASS="LITERAL"
>plain</TT
>のみが使用できます）。
<TT
CLASS="LITERAL"
>plain</TT
>を指定すると、その型のデータは常にインラインで格納され、圧縮されません。
<TT
CLASS="LITERAL"
>extended</TT
>を指定すると、システムはまず長いデータ値を圧縮しようとし、それでもまだ長過ぎる場合は値をメインテーブルの行から削除して移動します。
<TT
CLASS="LITERAL"
>external</TT
>はメインテーブルから値を削除して移動することを許しますが、システムはデータを圧縮しようとしません。
<TT
CLASS="LITERAL"
>main</TT
>はデータの圧縮を許し、できるだけ値をメインテーブルから削除しないようにします
（行を収めるために他に方法がない場合にはメインテーブルから削除されてしまう可能性がありますが、<TT
CLASS="LITERAL"
>extended</TT
>や<TT
CLASS="LITERAL"
>external</TT
>が指定されたアイテムよりも優先してメインテーブルに残されます）。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>like_type</I
></TT
>パラメータは、何らかの既存のデータ型から複製するという、データ型の基本表現プロパティを指定する、別の方法を提供します。
<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>passedbyvalue</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>の値が指定された型から複製されます。
（普通好まれませんが、<TT
CLASS="LITERAL"
>LIKE</TT
>句と一緒にこれらの値を指定することで、値を上書きすることも可能です。）
新しい型の低レベル実装にある流儀に従った既存の型を<SPAN
CLASS="QUOTE"
>"移す"</SPAN
>時に、この方法で表現を指定することが特に有用です。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>preferred</I
></TT
>パラメータは、暗黙的なキャストがあいまいな状況で適用されるかどうかについての制御を補助するために使用することができます。
各データ型は単一のASCII文字で命名されるカテゴリに属しています。
そして、各型はそのカテゴリで<SPAN
CLASS="QUOTE"
>"好まれる（preferred）"</SPAN
>か否かを持ちます。
パーサは（同一のカテゴリ内の他の型からの）好まれる型へのキャストを、この規則が上書きされた関数または演算子の解決に有用な場合に優先します。
より詳細は<A
HREF="typeconv.html"
>&#31532;10&#31456;</A
>を参照してください。
他の型への、または、ほかの型からの暗黙的なキャストを持たない型では、これらの設定をデフォルトのままにしておくことで十分です。
しかし、暗黙的なキャストを持つ関連するグループでは、それらすべてをカテゴリに属し、その1つまたは2つをカテゴリ内で好まれるものとして<SPAN
CLASS="QUOTE"
>"最も一般的な"</SPAN
>型として選択することが有用となる場合が多くあります。
ユーザ定義型を、数値型や文字列型などの既存の組み込みカテゴリに追加する場合に、<TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
>パラメータは特に有用です。
しかし、すべてがユーザ定義型のカテゴリを作成することもできます。
カテゴリとして命名されていない任意の大文字を選択してください。
  </P
><P
>ユーザがそのデータ型の列のデフォルトをNULL以外にしたい場合は、デフォルト値を指定することができます。
デフォルト値は<TT
CLASS="OPTION"
>DEFAULT</TT
>キーワードで指定してください
（この方法で指定されたデフォルト値は、特定の列に付与された、明示的な<TT
CLASS="OPTION"
>DEFAULT</TT
>句によって上書きされる可能性があります）。
  </P
><P
>データ型が配列であることを示すには、<TT
CLASS="OPTION"
>ELEMENT</TT
>キーワードを使用して配列要素の型を指定してください。
例えば、4バイト整数（<TT
CLASS="TYPE"
>int4</TT
>）の配列を定義するには、<TT
CLASS="LITERAL"
>ELEMENT = int4</TT
>と指定してください。
詳細は後述の配列型で説明します。
  </P
><P
>この型による配列の外部形式における値間の区切り文字を示すために、<TT
CLASS="REPLACEABLE"
><I
>delimiter</I
></TT
>で特定の文字を設定することができます。
デフォルトの区切り文字はカンマ（'<TT
CLASS="LITERAL"
>,</TT
>'）です。
この区切り文字は、配列要素の型に関係するものであり、配列型自体に関係するものでないことに注意してください。
  </P
><P
>省略可能な論理型の<TT
CLASS="REPLACEABLE"
><I
>collatable</I
></TT
>パラメータが真の場合、<TT
CLASS="LITERAL"
>COLLATE</TT
>句を使用することによって、列定義と型の式は照合順序情報を持つことができます。
照合順序情報を実際に使用するかどうかは、型に対する操作を行う関数実装に任されています。
照合順序を設定可能な型を作成することにより、これが自動的に行われることはほとんどありません。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN69072"
></A
><H3
>配列型</H3
><P
>ユーザ定義型が作成されると、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、自動的に、基本型名の前にアンダースコアを付け、必要に応じて<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>長より短くなるように切り詰められた名前を持つ、関連する配列型を作成します。
（こうして付けられた名前が既存の型名と競合する場合、競合する名称がなくなるまでこの処理が繰り返されます。）
この暗黙的に作成される配列型は可変長で、組み込み入出力関数<TT
CLASS="LITERAL"
>array_in</TT
>と<TT
CLASS="LITERAL"
>array_out</TT
>を使用します。
配列型はその要素となる型の所有者とスキーマのなんらかの変更に追従し、また、要素となる型が削除された場合に削除されます。
   </P
><P
>理論的に考えると、「システムが自動的に配列型を正しく作成するのであれば、<TT
CLASS="OPTION"
>ELEMENT</TT
>オプションはどうして存在するのだろう」と不思議に思うでしょう。
<TT
CLASS="OPTION"
>ELEMENT</TT
>が意味を持つ、唯一の場合は次のような条件を満たす固定長の型を作成する時です。
その条件とは、内部的に大量の同一の要素からなる配列となっていること、その配列に対して添字を指定して直接アクセスできること、加えて、今後作成する型全体に対する操作がどのようなものであっても、それらから直接アクセスできることです。
例えば、<TT
CLASS="TYPE"
>point</TT
>型では、その構成要素である2つの浮動小数点に<TT
CLASS="LITERAL"
>point[0]</TT
>および<TT
CLASS="LITERAL"
>point[1]</TT
>という方法でアクセスすることができます。
この機能は、その内部形式が同一の固定長フィールドの正確な並びである、固定長の型でのみ動作することに注意してください。
添字による指定が可能な可変長型は、<TT
CLASS="LITERAL"
>array_in</TT
>と<TT
CLASS="LITERAL"
>array_out</TT
>を使用して、一般化された内部表現を持つ必要があります。 
歴史的な理由（明らかに間違いなのですが、変更するには遅すぎたため）により、固定長配列型への要素番号指定は0から始まり、可変長配列の場合は1から始まります。 
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN69087"
></A
><H2
>パラメータ</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>作成するデータ型の名前です（スキーマ修飾名も可）。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>attribute_name</I
></TT
></DT
><DD
><P
>複合型用の属性（列）名です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
></DT
><DD
><P
>複合型の列となる、既存のデータ型の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>label</I
></TT
></DT
><DD
><P
>列挙型の1つの値に関連付けられるテキスト形式のラベルを表す、文字列リテラルです。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
></DT
><DD
><P
>指定された型のテキストによる外部形式のデータを内部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
></DT
><DD
><P
>指定された型の内部形式のデータをテキストによる外部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
></DT
><DD
><P
>指定された型のバイナリによる外部形式のデータを内部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
></DT
><DD
><P
>指定された型の内部形式のデータをバイナリによる外部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
></DT
><DD
><P
>型に関する修正子の配列を内部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
></DT
><DD
><P
>内部形式の型修正子をテキストの外部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
></DT
><DD
><P
>指定したデータ型の統計情報解析を行う関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
></DT
><DD
><P
>新しいデータ型の内部表現のバイト長を表す数値定数です。
デフォルトでは、可変長であるとみなされます。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
></DT
><DD
><P
>データ型の格納整列条件です。  
このオプションを指定する場合は、<TT
CLASS="LITERAL"
>char</TT
>、<TT
CLASS="LITERAL"
>int2</TT
>、<TT
CLASS="LITERAL"
>int4</TT
>、<TT
CLASS="LITERAL"
>double</TT
>のいずれかでなければなりません。 
デフォルトは<TT
CLASS="LITERAL"
>int4</TT
>です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
></DT
><DD
><P
>データ型の格納戦略です。
このオプションを指定する場合は、<TT
CLASS="LITERAL"
>plain</TT
>、<TT
CLASS="LITERAL"
>external</TT
>、<TT
CLASS="LITERAL"
>extended</TT
>、<TT
CLASS="LITERAL"
>main</TT
>のいずれかでなければなりません。 
デフォルトは<TT
CLASS="LITERAL"
>plain</TT
>です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>like_type</I
></TT
></DT
><DD
><P
>新しい型に同じ表現を持たせる既存のデータ型の名前です。
<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>passedbyvalue</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>の値が、この<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>コマンドのどこかで明示的な指定により上書きされない限り、型から複製されます。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
></DT
><DD
><P
>この型用のカテゴリコード（単一のASCII文字）です。
デフォルトは<SPAN
CLASS="QUOTE"
>"ユーザ定義型"</SPAN
>を表す<TT
CLASS="LITERAL"
>'U'</TT
>です。
他の標準カテゴリコードを<A
HREF="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE"
>&#34920;45-49</A
>に示します。
独自のカテゴリを作成するために他のASCII文字を選択することもできます。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>preferred</I
></TT
></DT
><DD
><P
>この型がカテゴリ内で好まれる型である場合に真、さもなくば偽です。
デフォルトは偽です。
動作に予想外の変化を引き起こしますので既存の型カテゴリに新しく好まれる型を作成することには十分注意してください。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>default</I
></TT
></DT
><DD
><P
>そのデータ型のデフォルト値です。
省略された場合、デフォルトはNULLです。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>element</I
></TT
></DT
><DD
><P
>配列型を作成する場合、その配列の要素の型を指定します。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>delimiter</I
></TT
></DT
><DD
><P
>このデータ型による配列で、値間の区切り文字として使われる文字です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>collatable</I
></TT
></DT
><DD
><P
>この型を操作する時に照合順序情報を使用することができる場合に真を取ります。
デフォルトは偽です。
     </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-NOTES"
></A
><H2
>注釈</H2
><P
>一度作成したデータ型の使用には制限はありませんので、基本型の作成は型定義で言及した関数の実行権をPUBLICに対して付与することと同じです。
この種の型定義において有用な関数では、これは通常問題になりません。
しかし、型を設計する前に、外部形式から、または、外部形式への変換を行う時に、その関数が<SPAN
CLASS="QUOTE"
>"秘密の"</SPAN
>情報を必要とするかどうか熟考してください。
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>バージョン8.3より前のバージョンでは、生成される配列型の名前は常に要素型の名前の前に１つのアンダースコア文字（<TT
CLASS="LITERAL"
>_</TT
>）を付けたものになりました。
（このため型の名前は他の名前よりも1文字短く制限されていました。）
通常はこのように名付けられることは変わりありませんが、最大長の名前の場合やアンダースコアから始まるユーザ定義の型と競合する場合、配列型の名前は変わることがあります。
このため、この変換に依存したコードを書くことは避けてください。
代わりに、<TT
CLASS="STRUCTNAME"
>pg_type</TT
>.<TT
CLASS="STRUCTFIELD"
>typarray</TT
>を使用して、指定した型に関した配列型を特定してください。
  </P
><P
>アンダースコアから始まる型やテーブル名の使用を避けることが賢明です。
サーバは生成された配列型名称をユーザ指定の名前と競合しないように変更しますが、混乱する危険があります。
特に古いクライアントソフトウェアを使用する場合、名前がアンダースコアから始まる型を常に配列を表すものと仮定しているかもしれません。
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>バージョン8.2より前まででは、<TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
>構文は存在しません。
新規に基本型を作成する方法は、最初に入力関数を作成することでした。
この方法では、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はまず新しいデータ型の名称を、入力関数の戻り値型から判断します。
この場合、シェル型が暗黙的に作成され、残りの入出力関数の定義で参照することができます。
この方法もまだ使用できますが、廃止予定で将来のリリースでなくなる可能性があります。
また、関数定義における単純な打ち間違いの結果作成されるシェル型によって起こるカタログの混乱を防止するため、入力関数がCで作成された場合にのみこの方法によってシェル型が作成されます。
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.3より前のバージョンでは、関数の下位参照を、プレースホルダとなる疑似データ型である<TT
CLASS="TYPE"
>opaque</TT
>型のデータ型名と置き換えることによって、shell型を作成することを完全に、慣習的に避けていました。
また、7.3より前のバージョンでは、<TT
CLASS="TYPE"
>cstring</TT
>型の引数および結果も<TT
CLASS="TYPE"
>opaque</TT
>型として宣言する必要がありました。
古いダンプファイルのロードをサポートするため、<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>では<TT
CLASS="TYPE"
>opaque</TT
>型を使用するよう宣言された入出力関数を受け入れます。
しかし、注意を促すメッセージを表示し、正しいデータ型を使用するように関数の宣言を変更します。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN69235"
></A
><H2
>例</H2
><P
>次の例では、複合型を作成し、それを関数定義で使用します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE compfoo AS (f1 int, f2 text);
CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;</PRE
><P>
  </P
><P
>次の例では、列挙型を作成し、それをテーブル定義に使用します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);</PRE
><P>
  </P
><P
>次の例では、<TT
CLASS="TYPE"
>box</TT
>基本データ型を作成し、その型をテーブル定義の中で使用しています。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);</PRE
><P>
  </P
><P
><TT
CLASS="TYPE"
>box</TT
>型の内部構造が<TT
CLASS="TYPE"
>float4</TT
>型が4つ並んだ配列の場合、このように書き換えることもできます。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);</PRE
><P>
このようにすると、box値の要素に要素番号でアクセスできます。
その他は、上の例と同様の動作をします。
  </P
><P
>次の例では、ラージオブジェクト型を作成し、テーブル定義にてそれを使用します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);</PRE
><P>
  </P
><P
>その他の例は、<A
HREF="xtypes.html"
>&#38917;35.11</A
>を参照してください。ここには、入力関数、出力関数などを使った例があります。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-COMPATIBILITY"
></A
><H2
>互換性</H2
><P
>複合型を作成する、最初の<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>コマンドの構文は標準<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>に従います。
他の構文は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。
標準<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>ではまた他の<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>構文を定義していますが、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では実装されていません。
  </P
><P
>ゼロ個の要素を持つ複合型を作成する機能は標準から派生した<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>固有のもの（<TT
CLASS="COMMAND"
>CREATE TABLE</TT
>同様）です。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-SEE-ALSO"
></A
><H2
>関連項目</H2
><A
HREF="sql-altertype.html"
>ALTER TYPE</A
>, <A
HREF="sql-createdomain.html"
>CREATE DOMAIN</A
>, <A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>, <A
HREF="sql-droptype.html"
>DROP TYPE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createtrigger.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createuser.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE TRIGGER</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE USER</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
