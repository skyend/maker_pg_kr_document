<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>レプリケーション</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="サーバの設定"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="ログ先行書き込み（WAL）"
HREF="runtime-config-wal.html"><LINK
REL="NEXT"
TITLE="問い合わせ計画"
HREF="runtime-config-query.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="SECT1"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="ログ先行書き込み（WAL）"
HREF="runtime-config-wal.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="サーバの設定"
HREF="runtime-config.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31532; 18&#31456;サーバの設定</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="サーバの設定"
HREF="runtime-config.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="問い合わせ計画"
HREF="runtime-config-query.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-REPLICATION"
>18.6. レプリケーション</A
></H1
><P
>     
      これらの設定は組み込みの<I
CLASS="FIRSTTERM"
>ストリーミングレプリケーション</I
>機能の動作を制御します（<A
HREF="warm-standby.html#STREAMING-REPLICATION"
>&#38917;25.2.5</A
>を参照ください）。
      いくつかのパラメータはマスターサーバで設定される必要がありますが、そのほかのパラメータはレプリケーションデータを受信するスタンバイサーバ（複数の場合もあります）で設定されなければなりません。
     </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-MASTER"
>18.6.1. マスターサーバ</A
></H2
><P
>      
      これらのパラメータはレプリケーションデータを１つ、またはそれ以上複数のスタンバイサーバに送るプライマリサーバ上で設定することができます。
      これらパラメータに加え、<A
HREF="runtime-config-wal.html#GUC-WAL-LEVEL"
>wal_level</A
>はマスターサーバ上で適切に設定される必要があり、管理者としては通常、WALアーカイビングも同じように有効にしたいと思うはずです（<A
HREF="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING"
>&#38917;18.5.3</A
>を参照してください）。
      スタンバイサーバがマスターサーバになるかもしれない状況に備え、それらのパラメータをスタンバイサーバで設定したいと考えたとしても、スタンバイサーバ上でのパラメータの値は意味をなしません。
     </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-MAX-WAL-SENDERS"
></A
><TT
CLASS="VARNAME"
>max_wal_senders</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	複数のスタンバイサーバ、またはストリーミングを基盤とする予備（バックアップ）クライアントからの同時接続を受ける接続最大値を設定します（つまり、同時に稼動するWAL送信プロセスの最大値です）。
	デフォルトはゼロです。このパラメータはサーバ起動時のみ設定可能です。
	スタンバイサーバからの接続を許可するには、<TT
CLASS="VARNAME"
>wal_level</TT
>が<TT
CLASS="LITERAL"
>archive</TT
>、または<TT
CLASS="LITERAL"
>hot_standby</TT
>に設定されなければなりません。
       </P
></DD
><DT
><A
NAME="GUC-WAL-SENDER-DELAY"
></A
><TT
CLASS="VARNAME"
>wal_sender_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	WAL送信プロセスに対する動作周回間の遅延を設定します。
	それぞれの周回で、WAL送信サーバはスタンバイサーバに最終周回で送った後に蓄積されたWALを送信します。
	そして、<TT
CLASS="VARNAME"
>wal_sender_delay</TT
>ミリ秒活を動停止し、そしてそれを繰り返します。
	活動休止はトランザクションのコミットにより中断されますので、この設定にかかわらず、コミットされたトランザクションの結果はコミット直後すぐさま、スタンバイサーバに送られます。
	デフォルトの値は1秒（<TT
CLASS="LITERAL"
>1s</TT
>）です。
	多くのシステムでは、有効な活動停止遅延の分解能は10ミリ秒です。10の倍数でない値に<TT
CLASS="VARNAME"
>wal_sender_delay</TT
>を設定しても、次の10の倍数に設定したのと同じ結果となります。このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-WAL-KEEP-SEGMENTS"
></A
><TT
CLASS="VARNAME"
>wal_keep_segments</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
        ストリーミングレプリケーションにおいて、スタンバイサーバが過去のファイルセグメントを取得する必要がある場合に備え、<TT
CLASS="FILENAME"
>pg_xlog</TT
>ディレクトリに保持しておくファイルセグメント数の最小値を指定します。
	それぞれのセグメントは通常16メガバイトです。もしプライマリサーバに接続しているスタンバイサーバが<TT
CLASS="VARNAME"
>wal_keep_segments</TT
>セグメントを越えて遅延した場合、プライマリサーバはスタンバイサーバが今後とも必要とするWALセグメントを削除する可能性があります。
	この場合、レプリケーション接続は終了させられます。（しかし、WALアーカイブが使用されていれば、スタンバイサーバはアーカイブからセグメントを取り出し、復旧することができます。）
       </P
><P
>       
	<TT
CLASS="FILENAME"
>pg_xlog</TT
>に保持され続けるセグメントの最小値のみを設定します。
	システムはWALアーカイブのため、またはチェックポイントからの復旧のため、より多くのセグメント保持が必要となることがあります。もし<TT
CLASS="VARNAME"
>wal_keep_segments</TT
>が（デフォルトの）ゼロの場合、システムは待機目的でのいかなる追加セグメントも保持しません。
        従って、スタンバイサーバが使用できる古いWALセグメントの多くは、前回のチェックポイントの場所とWALアーカイブの状態を捕捉する機能になります。
	このパラメータはリスタートポイントに影響を与えません。
	このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-VACUUM-DEFER-CLEANUP-AGE"
></A
><TT
CLASS="VARNAME"
>vacuum_defer_cleanup_age</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	<TT
CLASS="COMMAND"
>VACUUM</TT
>および<ACRONYM
CLASS="ACRONYM"
>HOT</ACRONYM
>更新が不必要となった行バージョンの後片付けをどれくらい遅らせるかをトランザクション数で設定します。
デフォルトはトランザクション数がゼロとなっていて、不必要となった行バージョンは可能な限り迅速に、つまり実行中のどんなトランザクションから見えなくなり次第削除されます。
<A
HREF="hot-standby.html"
>&#38917;25.5</A
>で記述されているように、ホットスタンバイ構成のプライマリサーバにて、この設定を非ゼロにしたいと思う場合もあります。
そうすることで、行を早期に後片付けすることによっておこる衝突を招かずに、スタンバイサーバ上での問い合わせに対して時間をより多く割くことができます。
	しかし、この値はプライマリサーバ上で発生する書き込みトランザクション数で測られるので、待機中の問い合わせにどれだけ多くの追加猶予時間を与えられるかを予想することはできません。
	このパラメータは <TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみで設定可能です。
       </P
><P
>       
	このパラメータを使用する代わりとして、<TT
CLASS="VARNAME"
>hot_standby_feedback</TT
>を設定することも同時に考慮したほうが良いでしょう。
       </P
></DD
><DT
><A
NAME="GUC-REPLICATION-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>replication_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	指定されたミリ秒単位の値より長く非活動のレプリケーション接続を停止します。
	スタンバイサーバのクラッシュ、またはネットワークの停止をプライマリーサーバが検出することにこれが役立ちます。
	値ゼロはタイムアウト機能を無効にします。
	このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
	デフォルトの値は60秒です。
       </P
><P
>       
	時期尚早に接続が停止されることを防ぐため、スタンバイサーバで<A
HREF="runtime-config-replication.html#GUC-WAL-RECEIVER-STATUS-INTERVAL"
>wal_receiver_status_interval</A
>が必ず有効になっていなければなりません。
	また、その値は<TT
CLASS="VARNAME"
>replication_timeout</TT
>の値未満でなければなりません。
       </P
></DD
><DT
><A
NAME="GUC-SYNCHRONOUS-STANDBY-NAMES"
></A
><TT
CLASS="VARNAME"
>synchronous_standby_names</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>       
	<A
HREF="warm-standby.html#SYNCHRONOUS-REPLICATION"
>&#38917;25.2.6</A
>で説明されているように、<I
CLASS="FIRSTTERM"
>同期レプリケーション</I
>をサポート可能なコンマで区切られたリストでスタンバイサーバの名前を指定します。
	いつの時点においても、最低限一つの活動している同期スタンバイサーバが存在します。
	コミットを待機しているトランザクションは、このスタンバイサーバがそのデータの受信を確認してから処理の継続が許可されます。
	同期スタンバイサーバはこのリストで一番目に名前が挙げられていており、現時点で接続され、そしてデータをリアルタイムでストリーミングしているものです（<A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
>        <TT
CLASS="LITERAL"
>pg_stat_replication</TT
></A
> ビューにおいて<TT
CLASS="LITERAL"
>ストリーミング</TT
>状態として示されています）。
	このリストの後の方に記載されているその他のスタンバイサーバは潜在的に同期スタンバイサーバになることを示しています。
	もし現在の同期スタンバイサーバが理由にかかわらず切断された場合、次に順位の高いスタンバイサーバがすぐに取って代わります。
	二つ以上のスタンバイサーバ名を指定することでかなりの高可容性が得られます。
       </P
><P
>       
	この目的のスタンバイサーバの名前は、スタンバイサーバのwalreceiverの<TT
CLASS="VARNAME"
>primary_conninfo</TT
>で設定されるのと同じく、スタンバイサーバの<TT
CLASS="VARNAME"
>application_name</TT
>設定となります。
	一意性を強要する仕組みにはなっていません。
	<TT
CLASS="LITERAL"
>walreceiver</TT
>のデフォルトのアプリケーション名を含めて、特別の記載である<TT
CLASS="LITERAL"
>*</TT
>は全ての<TT
CLASS="VARNAME"
>application_name</TT
>にマッチします。
       </P
><P
>       
	ここに同期スタンバイ名が指定されていない場合、同期レプリケーションは有効とはならず、トランザクションコミットはレプリケーションを待機しません。これがデフォルトの設定です。同期レプリケーションが有効であっても、<A
HREF="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT"
>synchronous_commit</A
>パラメータを<TT
CLASS="LITERAL"
>local</TT
> または <TT
CLASS="LITERAL"
>off</TT
>に設定することにより、個別のトランザクションをレプリケーションに対して待機しないように設定できます。
       </P
><P
>       
	このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-REPLICATION-STANDBY"
>18.6.2. スタンバイサーバ</A
></H2
><P
>     
      これらの設定はレプリケーションデータを受け取るスタンバイサーバの動作を管理します。
      マスターサーバ上のこれらの値は無意味です。
     </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-HOT-STANDBY"
></A
><TT
CLASS="VARNAME"
>hot_standby</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>       
	<A
HREF="hot-standby.html"
>&#38917;25.5</A
>に記載されている通り、リカバリの最中に接続し、そして問い合わせを実行できるか否かを設定します。デフォルト値は<TT
CLASS="LITERAL"
>off</TT
>です。
	このパラメータはサーバ起動時のみ設定可能です。これは、アーカイブリカバリ期間、又は待機モードにある場合にのみ効果をもたらします。
       </P
></DD
><DT
><A
NAME="GUC-MAX-STANDBY-ARCHIVE-DELAY"
></A
><TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
        ホットスタンバイが稼動している場合、このパラメータは<A
HREF="hot-standby.html#HOT-STANDBY-CONFLICT"
>&#38917;25.5.2</A
>で記載されているように、まさに適用されようとしているWALエントリと衝突するスタンバイサーバの問い合わせをキャンセルするにはどれだけ待機しなければならないかを設定します。
        <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
>はWALデータをWALアーカイブから読み込んでいる時に適用されます（従って最新ではありません）。
	デフォルトは30秒です。特に指定が無ければ単位はミリ秒です。値-1は衝突する問い合わせが完了するまでスタンバイサーバが待ち続けられるようにします。
	このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
       </P
><P
>       
        <TT
CLASS="VARNAME"
>max_standby_archive_delay</TT
>はキャンセル前に問い合わせが実行できる最大の時間の長さと同じでないことに注意してください。むしろ、任意の１つのWALセグメントのデータに適用される最大許可時間です。従って、ある問い合わせがWALセグメント内で時間的に初期の段階で大幅な遅延となった場合、その後の衝突する問い合わせの猶予時間はましてさらに短くなります。
       </P
></DD
><DT
><A
NAME="GUC-MAX-STANDBY-STREAMING-DELAY"
></A
><TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
        ホットスタンバイが稼動している場合、このパラメータは<A
HREF="hot-standby.html#HOT-STANDBY-CONFLICT"
>&#38917;25.5.2</A
>で記載されているように、まさに適用されようとしているWALエントリと衝突するスタンバイサーバの問い合わせをキャンセルするにはどれだけ待機しなければならないかを設定します。
        <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
>はWALデータをストリーミングレプリケーションから受け取っている時に適用されます。
	デフォルトは30秒です。特に指定が無ければ単位はミリ秒です。値-1は衝突する問い合わせが完了するまでスタンバイサーバが待ち続けられるようにします。
	このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
       </P
><P
>       
        <TT
CLASS="VARNAME"
>max_standby_streaming_delay</TT
>はキャンセル前に問い合わせが実行できる最大の時間の長さと同じでないことに注意してください。むしろ、一度プライマリサーバから受け取られたWALデータに適用される最大許可時間です。
        従って、ある問い合わせが大幅な遅延となった場合、スタンバイサーバがふたたび遅れを取り戻すまで、その後の衝突する問い合わせの猶予時間はましてさらに短くなります。
       </P
></DD
><DT
><A
NAME="GUC-WAL-RECEIVER-STATUS-INTERVAL"
></A
><TT
CLASS="VARNAME"
>wal_receiver_status_interval</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>      
       プライマリーに対してレプリケーションの進捗についての情報を送信するため、スタンバイ上のWAL受信プロセスの最小頻度を指定します。ここで、<A
HREF="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE"
>       <TT
CLASS="LITERAL"
>pg_stat_replication</TT
></A
>ビューにより確認することが可能です。
       スタンドバイサーバは既に書き込まれた最終のログ位置を報告し、その最終位置がディスクにフラッシュされ、その最終位置が適用されます。
       このパラメータの値がそれぞれの報告間における秒単位の最大の時間間隔です。
       書き込み、またはフラッシュ位置が変更される毎に更新が行われます。
       あるいは、少なくともこのパラメータで設定された頻度で行われます。
       このパラメータをゼロに設定すると、ステータスの更新を完全に無効化します。
       このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
	デフォルトの値は10秒です。   
      </P
><P
>      
       プライマリー上で<A
HREF="runtime-config-replication.html#GUC-REPLICATION-TIMEOUT"
>replication_timeout</A
>が有効になっている場合、<TT
CLASS="VARNAME"
>wal_receiver_status_interval</TT
>も有効になっていなければなりません。
       そして、その値は<TT
CLASS="VARNAME"
>replication_timeout</TT
>の値未満である必要があります。
      </P
></DD
><DT
><A
NAME="GUC-HOT-STANDBY-FEEDBACK"
></A
><TT
CLASS="VARNAME"
>hot_standby_feedback</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>       
	ホットスタンバイがスタンバイサーバ上で現在処理を行っている問い合わせについて、プライマリーにフィードバックを送るか否かを指定します。
	このパラメータはレコードの後片付けに起因する問い合わせの取り消しを排除するために使用することができます。
	しかし、いくつかの作業負荷に対してはプライマリーサーバ上でのデータベース肥大の原因となります。
	フィードバックメッセージは<TT
CLASS="VARNAME"
>wal_receiver_status_interval</TT
>毎に、一回以上送信されません。
	デフォルトの値は<TT
CLASS="LITERAL"
>off</TT
>です。
	 このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、もしくはサーバコマンドラインでのみ設定可能です。
       </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-wal.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-query.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ログ先行書き込み（WAL）</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>問い合わせ計画</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
