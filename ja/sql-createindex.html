<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE INDEX</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE GROUP"
HREF="sql-creategroup.html"><LINK
REL="NEXT"
TITLE="CREATE LANGUAGE"
HREF="sql-createlanguage.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="REFENTRY"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE GROUP"
HREF="sql-creategroup.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE GROUP"
HREF="sql-creategroup.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE LANGUAGE"
HREF="sql-createlanguage.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE LANGUAGE"
HREF="sql-createlanguage.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATEINDEX"
></A
>CREATE INDEX</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN65711"
></A
><H2
>&#21517;&#21069;</H2
>CREATE INDEX&nbsp;--&nbsp;新しいインデックスを定義する
  </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN65716"
></A
><H2
>&#27010;&#35201;</H2
><PRE
CLASS="SYNOPSIS"
>CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ] ON <TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
> [ USING <TT
CLASS="REPLACEABLE"
><I
>method</I
></TT
> ]
    ( { <TT
CLASS="REPLACEABLE"
><I
>column</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ) } [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] ) ]
    [ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>tablespace</I
></TT
> ]
    [ WHERE <TT
CLASS="REPLACEABLE"
><I
>predicate</I
></TT
> ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN65729"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は、指定したテーブルの指定した列(複数可)に対するインデックスを作ります。
インデックスは主にデータベースの性能を向上するために使われます
（しかし、インデックスの不適切な使用は性能の低下につながる可能性があります）。
  </P
><P
>インデックスのキーフィールドは、列名、または括弧に囲まれた式として指定されます。
インデックスメソッドが複数列に対するインデックスをサポートする場合は、複数のフィールドを指定できます。
  </P
><P
>インデックスのフィールドとして、テーブル行の1つ以上の列の値を計算する式を指定できます。
この機能は、元のデータに何らかの変換を加えた値を基とするデータへの高速なアクセスを行う手段として使用することができます。
例えば、<TT
CLASS="LITERAL"
>upper(col)</TT
>という計算に基づくインデックスがあれば、<TT
CLASS="LITERAL"
>WHERE upper(col) = 'JIM'</TT
>句ではインデックスを使用することができます。
  </P
><P
><SPAN
CLASS="APPLICATION"
>PostgreSQL</SPAN
>はB-tree、hash、GiST、GINのインデックスメソッドを用意しています。
ユーザが独自にインデックスメソッドを定義することもできますが、これはかなり複雑です。
  </P
><P
><TT
CLASS="LITERAL"
>WHERE</TT
>句が存在する場合、<I
CLASS="FIRSTTERM"
>部分インデックス</I
>が作成されます。
部分インデックスは、テーブルの一部、通常は、テーブルの中でよりインデックスが有用な部分のみのエントリを持つインデックスです。
例えば、支払済みの注文と未支払の注文を情報として持つテーブルがあり、テーブル全体における未支払の注文の割合が小さく、かつ、頻繁に使用される場合、未支払の注文のみにインデックスを作成することで性能を向上できます。
部分インデックスのその他の利用方法として、<TT
CLASS="COMMAND"
>UNIQUE</TT
>付きの<TT
CLASS="COMMAND"
>WHERE</TT
>を使用して、テーブルの一部に一意性を強制する例が考えられます。
詳細は<A
HREF="indexes-partial.html"
>&#38917;11.8</A
>を参照してください。
  </P
><P
><TT
CLASS="LITERAL"
>WHERE</TT
>句内の式では、元となるテーブルの列のみを参照できます。
しかし、インデックスを付加する列だけではなく、全ての列を使用することができます。
また、現在、副問い合わせと集約式については、<TT
CLASS="COMMAND"
>WHERE</TT
>で使用することができません。
同一の制限は、式で表されたインデックスのフィールドにも適用されます。
  </P
><P
>インデックスの定義で使用される全ての関数と演算子は、<SPAN
CLASS="QUOTE"
>"不変"</SPAN
>（immutable）でなければなりません。
つまり、結果は入力引数にのみに依存し、（他のテーブルの内容や現時刻などの）外部からの影響を受けてはなりません。
この制限によって、インデックスの動作が十分定義されていることが保証されます。  
インデックス式や<TT
CLASS="LITERAL"
>WHERE</TT
>句にユーザ定義の関数を使用する場合、関数を作成する際、IMMUTABLE（不変）オプションを付けることを忘れないでください。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN65751"
></A
><H2
>パラメータ</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>UNIQUE</TT
></DT
><DD
><P
>インデックスを（既にデータがある状態で）作成する時、テーブルにデータを追加する時に、テーブル内の値が重複していないかを検査します。
重複エントリを生じるデータの挿入または更新はエラーとなります。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>CONCURRENTLY</TT
></DT
><DD
><P
>このオプションを使用すると、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、対象テーブルに対する同時挿入、更新、削除を防止するようなロックを獲得せずにインデックスを作成します。
通常のインデックス作成処理では、完了するまで対象テーブルへの書き込みはロックされます（読み取りはロックされません）。
このオプションを使用する際に注意しなければならない点が複数あります。
<A
HREF="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY"
><I
>インデックスの同時作成</I
></A
>を参照してください。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>作成するインデックスの名前です。 
この名前には、スキーマ名を含めることはできません。
インデックスは、常にその親テーブルと同じスキーマに作成されます。
この名前を省略すると、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はその親テーブルの名前とインデックス付けされる列名に基づいた適切な名前を選びます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>table</I
></TT
></DT
><DD
><P
>インデックスを作成するテーブルの名前です（スキーマ修飾名の場合もあります）。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>method</I
></TT
></DT
><DD
><P
>使用するインデックスメソッドの名前です。
<TT
CLASS="LITERAL"
>btree</TT
>、<TT
CLASS="LITERAL"
>hash</TT
>、<TT
CLASS="LITERAL"
>gist</TT
>、<TT
CLASS="LITERAL"
>gin</TT
>から選択します。
デフォルトのメソッドは<TT
CLASS="LITERAL"
>btree</TT
>です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>column</I
></TT
></DT
><DD
><P
>テーブルの列の名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
></DT
><DD
><P
>テーブル上の1つ以上の列を使用した式です。
通常この式は、構文で示した通り括弧で囲む必要があります。
しかし、式が関数呼び出し形式になっている場合は括弧を省略することができます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
></DT
><DD
><P
>インデックスで使用する照合順序の名前です。
デフォルトではインデックスはインデックス付け対象の列で宣言された照合順序またはインデックス付け対象の式の結果照合順序を使用します。
デフォルト以外の照合順序を使用する式を含む問い合わせで、デフォルト以外の照合順序を持つインデックスが有用になるかもしれません。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
></DT
><DD
><P
>演算子クラスの名前です。詳細は下記を参照してください。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ASC</TT
></DT
><DD
><P
>（デフォルトの）正方向のソート順を指定します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>DESC</TT
></DT
><DD
><P
>逆方向のソート順を指定します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>NULLS FIRST</TT
></DT
><DD
><P
>NULLを非NULLより前にソートすることを指定します。
これは<TT
CLASS="LITERAL"
>DESC</TT
>が指定された場合のデフォルトです。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>NULLS LAST</TT
></DT
><DD
><P
>NULLを非NULLより後にソートすることを指定します。
これは<TT
CLASS="LITERAL"
>DESC</TT
>が指定されない場合のデフォルトです。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
></DT
><DD
><P
>インデックス固有の格納パラメータの名前です。
<A
HREF="sql-createindex.html#SQL-CREATEINDEX-STORAGE-PARAMETERS"
><I
>インデックス格納パラメータ</I
></A
>を参照してください。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>tablespace</I
></TT
></DT
><DD
><P
>インデックスを生成するテーブル空間です。
指定されなかった場合、<A
HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE"
>default_tablespace</A
>、もし一時テーブル上のインデックスであれば、<A
HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES"
>temp_tablespaces</A
>が考慮されます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>predicate</I
></TT
></DT
><DD
><P
>部分インデックス用の制約式です。
       </P
></DD
></DL
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATEINDEX-STORAGE-PARAMETERS"
></A
><H3
>インデックス格納パラメータ</H3
><P
>省略可能な<TT
CLASS="LITERAL"
>WITH</TT
>句では、インデックスに対し<I
CLASS="FIRSTTERM"
>格納パラメータ</I
>を指定します。
インデックスメソッドはそれぞれ固有の設定可能な格納パラメータを持ちます。
<TT
CLASS="LITERAL"
>B-tree</TT
>、<TT
CLASS="LITERAL"
>hash</TT
>および<TT
CLASS="LITERAL"
>GiST</TT
>といったインデックスはすべて以下の1つのパラメータを受け付けます。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>FILLFACTOR</TT
></DT
><DD
><P
>インデックス用のフィルファクタは割合（パーセント）で、インデックスメソッドがインデックスページをまとめ上げる時にどの程度ページを使用するかを決定するものです。
B-treeでは、リーフページは初期インデックス構築時と右側（新しい最大キー値を追加する方向）にインデックスを拡張する時にこの割合分ページを使用します。
その後ページすべてが完全に使用されると、インデックスの効果が緩やかに劣化するように分割されます。
B-treeのデフォルトのフィルファクタは90ですが、10から100までの任意の整数値を設定することができます。
テーブルの変化がほとんどない場合、100が最善でインデックスの物理サイズが最小化できます。
更新が非常に多い場合は、より小さなフィルファクタを設定することで、ページ分割の頻度を少なくすることができます。
この他のインデックスメソッドでは、フィルファクタをおおよそは同じですが、異なる意味で使用します。
メソッドによってフィルファクタのデフォルト値は異なります。
     </P
></DD
></DL
></DIV
><P
>GINインデックスでは以下の異なるパラメータを受け付けます。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>FASTUPDATE</TT
></DT
><DD
><P
>この設定は<A
HREF="gin-implementation.html#GIN-FAST-UPDATE"
>&#38917;54.3.1</A
>で説明する高速更新技法を使用するかどうかを制御します。
これは論理値パラメータであり、<TT
CLASS="LITERAL"
>ON</TT
>は高速更新を有効に、<TT
CLASS="LITERAL"
>OFF</TT
>は無効にします。
（<A
HREF="config-setting.html"
>&#38917;18.1</A
>の説明のように、<TT
CLASS="LITERAL"
>ON</TT
>と<TT
CLASS="LITERAL"
>OFF</TT
>の別記載も可能です。）
デフォルトは<TT
CLASS="LITERAL"
>ON</TT
>です。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>&#27880;&#24847;: </B
><TT
CLASS="COMMAND"
>ALTER INDEX</TT
>を使用して<TT
CLASS="LITERAL"
>FASTUPDATE</TT
>を無効にすることにより、今後の挿入は待機中のインデックス項目リストに入らないようになります。
しかし、このコマンド自体はこれまでの項目を吐き出しません。
確実に待機中のリストを空にするためには、続いてテーブルを<TT
CLASS="COMMAND"
>VACUUM</TT
>する方が良いでしょう。
     </P
></BLOCKQUOTE
></DIV
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATEINDEX-CONCURRENTLY"
></A
><H3
>インデックスの同時作成</H3
><P
>インデックスの作成が、通常のデータベース操作に影響を与えることがあります。
通常<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、対象テーブルに対する書き込みをロックしてから、対象テーブルを一度スキャンして全体をインデックス付けします。
他のトランザクションはテーブルを読み取ることはできますが、対象テーブル内の行を挿入、更新、削除しようとすると、インデックス作成が完了するまでブロックされます。
活発な運用状態のデータベースシステムの場合、これは重大な影響を与えます。
非常に大規模なテーブルに対するインデックス作成は何時間もかかることがあり得ます。
また小規模なテーブルであっても、インデックス作成により、運用状態のシステムでは受け入れられない期間、書き込みロックがかかる可能性があります。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は書き込みをロックしないインデックス作成もサポートしています。
<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>に<TT
CLASS="LITERAL"
>CONCURRENTLY</TT
>オプションをつけることでこの方式が行われます。
このオプションを使うと、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はテーブルを2回スキャンしなければなりません。
さらに、潜在的にそのインデックスを使用する可能性がある、実行中のすべてのトランザクションが終わるまで待機しなければなりません。
したがって、この方式は通常の方式よりも総作業時間がかかり、また、完了するまでの時間が非常に長くなります。
しかし、インデックス作成中に通常の操作を行い続けることができますので、この方式は運用環境での新規インデックス作成に有用です。
もちろん、インデックス作成によりCPUや入出力に負荷がかかりますので、他の操作が低速になる可能性があります。
   </P
><P
>同時実行インデックス構築では実際、インデックスは第一トランザクションでシステムカタログに登録され、第二および第三トランザクションで2つのテーブルのスキャンが起こります。
第二のテーブルスキャンの時に、そのテーブルに関連するものだけではなく、すべての実行中のトランザクションは、その完了までの間、同時実行インデックス作成をブロックする可能性があります。
元のインデックスを使用する可能性があるトランザクションの検査時、同時実行インデックス作成は、その時に潜在的に干渉するより古いトランザクションを、完了するまで待機できるようにその仮想トランザクション識別子に対する共有ロックを入手して、進めます。
   </P
><P
>たとえば一意性インデックスにおける一意性違反など、テーブルスキャン中に問題が発生すると、<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は失敗しますが、<SPAN
CLASS="QUOTE"
>"無効な"</SPAN
>インデックスが残ってしまいます。
こうしたインデックスは完全ではない可能性がありますので、問い合わせの際には無視されます。
しかし、更新時にオーバーヘッドがかかります。
<SPAN
CLASS="APPLICATION"
>psql</SPAN
>の<TT
CLASS="COMMAND"
>\d</TT
>コマンドでは、こうしたインデックスを<TT
CLASS="LITERAL"
>INVALID</TT
>として報告します。
</P><PRE
CLASS="PROGRAMLISTING"
>postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers 
--------+---------+-----------
 col    | integer | 
Indexes:
    "idx" btree (col) INVALID</PRE
><P>

こうした場合の推奨復旧方法は、インデックスを削除し、再度<TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>を実行することです。
（他にも<TT
CLASS="COMMAND"
>REINDEX</TT
>を使用したインデックスの再作成という方法もあります。
しかし、<TT
CLASS="COMMAND"
>REINDEX</TT
>は同時作成をサポートしていませんので、この方法は魅力がありません。）
   </P
><P
>この他に一意性インデックスを同時作成する場合の注意事項があります。
2回目のテーブルスキャンが始まる時点で、他のトランザクションに対する一意性制約が既に有効になっているという点です。
これは、インデックスが使用できるようになる前やインデックス作成が最終的に失敗したとしても、制約違反が他のトランザクションで報告されてしまうことを意味します。
また、2回目のスキャン中に失敗した後も、<SPAN
CLASS="QUOTE"
>"無効な"</SPAN
>インデックスによる一意性制約は強制され続けます。

   </P
><P
>式インデックスや部分インデックスの同時作成もサポートされています。
式の評価中にエラーが発生した場合も、上で説明した一意性制約違反と同様な状況が発生します。
   </P
><P
>同一テーブルに対する通常のインデックス作成処理は複数並行して行うことができます。
しかし、あるテーブルに対するインデックスの同時作成は一度に1つしか行うことができません。
また、どの場合でもインデックス作成中はテーブルスキーマの変更はできません。
この他に、通常の<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>コマンドはトランザクションブロック内で実行させることができますが、<TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>は実行させることができないという相違点があります。
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN65909"
></A
><H2
>注釈</H2
><P
>インデックスが、どのような時に使用され、どのような時に使用されないか、また、どのような場合に有用かといった情報については<A
HREF="indexes.html"
>&#31532;11&#31456;</A
>を参照してください。
  </P
><P
>    
現在は、B-tree、GiST、GINインデックスメソッドのみが、複数列に対するインデックスをサポートしています。
指定できる列は、デフォルトでは32個までです（この制限は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>構築の際に変更できます）。
現在、B-treeのみが一意性インデックスをサポートしています。

  </P
><P
><I
CLASS="FIRSTTERM"
>演算子クラス</I
>は、インデックスのそれぞれの列に指定することができます。
演算子クラスは、その列のインデックスが使う演算子を識別します。
例えば、4バイト整数に対するB-treeインデックスには、<TT
CLASS="LITERAL"
>int4_ops</TT
>クラスを使います。
この演算子クラスには、4バイト整数の比較関数が含まれています。
実際の使用では、通常、列のデータ型のデフォルト演算子クラスで十分です。
演算子クラスを保持する主な理由は、データ型の中には有意な順序を2つ以上持つものがあるかもしれないからです。
例えば、絶対値または実数部のどちらかを使って複素数のデータ型をソートしたい場合がありえます。
これを実現するには、データ型として2つの演算子クラスを定義し、インデックスを作る時に適切なクラスを選択します。
演算子クラスについての詳細は、<A
HREF="indexes-opclass.html"
>&#38917;11.9</A
>と<A
HREF="xindex.html"
>&#38917;35.14</A
>を参照してください。
  </P
><P
>順序付きスキャンをサポートするインデックスメソッド（現時点ではB-Treeのみ）では、省略可能な<TT
CLASS="LITERAL"
>ASC</TT
>、<TT
CLASS="LITERAL"
>DESC</TT
>、<TT
CLASS="LITERAL"
>NULLS FIRST</TT
>、<TT
CLASS="LITERAL"
>NULLS LAST</TT
>句を指定し、インデックスのソート順を変更させることができます。
順序付きインデックスは正方向にも逆方向にもスキャンすることができますので、単一列に対する<TT
CLASS="LITERAL"
>DESC</TT
>インデックスは通常は有用ではありません。
このソート順序はすでに通常のインデックスを使用して実現できます。
これらのオプションの価値は、<TT
CLASS="LITERAL"
>SELECT ... ORDER BY x ASC, y DESC</TT
>などの順序指定が混在する問い合わせによって要求されるソート順に一致する、複数列に対するインデックスを作成できる点です。
<TT
CLASS="LITERAL"
>NULLS</TT
>オプションは、ソート処理を中断するインデックスに基づいた問い合わせにおける<SPAN
CLASS="QUOTE"
>"NULLのソート順を低くする"</SPAN
>動作をサポートする必要がある場合に有用です。
デフォルトの動作は<SPAN
CLASS="QUOTE"
>"NULLのソート順を高くする"</SPAN
>です。
  </P
><P
>ほとんどのインデックスメソッドにおいて、インデックス作成速度は<A
HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"
>maintenance_work_mem</A
>の設定に依存します。
より大きな値を設定すると、マシンをスワップ状態にしてしまわないように実際に使用できるメモリ量を超えないようにしている限り、インデックス作成が必要となる回数を減少します。
ハッシュインデックスでは、<A
HREF="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE"
>effective_cache_size</A
>の値もインデックス作成時間に影響を与えます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、推定インデックスサイズが<TT
CLASS="VARNAME"
>effective_cache_size</TT
>より大きいか小さいかによって、2つのハッシュインデックス作成方法の内どちらかを使用します。
最善の結果を得るために、このパラメータが利用可能なメモリを反映した値に設定されていることを確認してください。
また、<TT
CLASS="VARNAME"
>maintenance_work_mem</TT
>と<TT
CLASS="VARNAME"
>effective_cache_size</TT
>の和が、マシンのRAM容量から他のプログラムで必要とされる容量を差し引いた容量より小さくなるよう注意してください。
  </P
><P
>インデックスを削除するには、<A
HREF="sql-dropindex.html"
>DROP INDEX</A
>を使用してください。
  </P
><P
>以前の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>にはR-treeインデックスメソッドがありました。
GiSTメソッドに比べて大きな利点がありませんでしたので、このメソッドは削除されました。
古いデータベースからGiSTへの変換を簡単にするため、<TT
CLASS="LITERAL"
>USING rtree</TT
>が指定された場合、<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は<TT
CLASS="LITERAL"
>USING gist</TT
>と解釈します。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN65944"
></A
><H2
>例</H2
><P
><TT
CLASS="LITERAL"
>films</TT
>テーブルの<TT
CLASS="LITERAL"
>title</TT
>列にB-treeインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX title_idx ON films (title);</PRE
><P>
  </P
><P
>大文字小文字を区別しない検索が効率的になるように、<TT
CLASS="LITERAL"
>lower(title)</TT
>式に対してインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX ON films ((lower(title)));</PRE
><P>
(この例では、インデックス名を省略することを選びました。
このためシステムが名前、通常は<TT
CLASS="LITERAL"
>films_lower_idx</TT
>という名前を選ぶことになるでしょう。)
  </P
><P
>デフォルト以外の照合順序でインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");</PRE
><P>
  </P
><P
>デフォルト以外のNULLのソート順を指定したインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);</PRE
><P>
  </P
><P
>デフォルト以外のフィルファクタを持つインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);</PRE
><P>
  </P
><P
>高速更新を無効にして<ACRONYM
CLASS="ACRONYM"
>GIN</ACRONYM
>インデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX gin_idx ON documents_table USING gin (locations) WITH (fastupdate = off);</PRE
><P>
  </P
><P
><TT
CLASS="LITERAL"
>films</TT
>テーブル上に<TT
CLASS="LITERAL"
>code</TT
>列に対するインデックスを作成します。
また、このインデックスを<TT
CLASS="LITERAL"
>indexspace</TT
>テーブル空間内に生成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;</PRE
><P>
  </P
><P
>変換関数の結果に対するbox操作を効率的に使用できるようにpoint属性にGiSTインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;</PRE
><P>
  </P
><P
>対象テーブルへの書き込みをロックせずにインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN65972"
></A
><H2
>互換性</H2
><P
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。
標準SQLにはインデックスについての規定はありません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN65977"
></A
><H2
>関連項目</H2
><A
HREF="sql-alterindex.html"
>ALTER INDEX</A
>, <A
HREF="sql-dropindex.html"
>DROP INDEX</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-creategroup.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createlanguage.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE GROUP</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE LANGUAGE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
