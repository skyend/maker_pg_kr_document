<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>ログ先行書き込み（WAL）</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="サーバの設定"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="資源の消費"
HREF="runtime-config-resource.html"><LINK
REL="NEXT"
TITLE="レプリケーション"
HREF="runtime-config-replication.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="SECT1"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="資源の消費"
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="サーバの設定"
HREF="runtime-config.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31532; 18&#31456;サーバの設定</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="サーバの設定"
HREF="runtime-config.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="レプリケーション"
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-WAL"
>18.5. ログ先行書き込み（WAL）</A
></H1
><P
>   
    WALとチェックポイントの調整についての詳細は<A
HREF="wal-configuration.html"
>&#38917;29.4</A
>も参照してください。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-SETTINGS"
>18.5.1. 諸設定</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-WAL-LEVEL"
></A
><TT
CLASS="VARNAME"
>wal_level</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)</DT
><DD
><P
>       
	<TT
CLASS="VARNAME"
>wal_level</TT
>はどれだけの情報がWALに書かれるかを決定します。
	デフォルト値は<TT
CLASS="LITERAL"
>minimal</TT
>で、クラッシュまたは即時停止から回復するのに必要な情報のみ書き出します。
	<TT
CLASS="LITERAL"
>archive</TT
>はWALアーカイビングに必要なロギングを追加し、<TT
CLASS="LITERAL"
>hot_standby</TT
>は更にスタンバイサーバ上の読み取り専用問い合わせの情報を追加します。
	このパラメータはサーバ起動時のみ設定可能です。
       </P
><P
>       
	<TT
CLASS="LITERAL"
>minimal</TT
>水準では、何らかの巨大な操作でのWALロギングは安全を期して省略されます。そうすることで、一連の操作をより高速にさせます（<A
HREF="populate.html#POPULATE-PITR"
>&#38917;14.4.7</A
>を参照してください）。
	この最適化が適用される操作には以下のものがあげられます。
	 <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE TABLE AS</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CLUSTER</TT
></TD
></TR
><TR
><TD
>同一トランザクション内で作成されたか、もしくは切り詰められたテーブルに対する<TT
CLASS="COMMAND"
>COPY</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
>
	しかしminimal WALはベースバックアップとWALログからデータを再構築するための充分な情報を持ち合わせていません。したがい、WALアーカイビング（<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE"
>archive_mode</A
>）とストリーミングレプリケーションを有効にするには<TT
CLASS="LITERAL"
>archive</TT
>または<TT
CLASS="LITERAL"
>hot_standby</TT
>水準を使用しなければなりません。
       </P
><P
>       
	<TT
CLASS="LITERAL"
>hot_standby</TT
>水準においては、<TT
CLASS="LITERAL"
>archive</TT
>と同じ情報がログ取得されるのに加え、WALから実行中のトランザクション状態を再構築するのに必要な情報が得られます。
	スタンバイサーバ上で読み取り専用問い合わせを有効にするには、<TT
CLASS="LITERAL"
>hot_standby</TT
>がプライマリサーバで設定され、<A
HREF="runtime-config-replication.html#GUC-HOT-STANDBY"
>hot_standby</A
>がスタンバイサーバで有効になっていなければなりません。
	<TT
CLASS="LITERAL"
>hot_standby</TT
>水準と<TT
CLASS="LITERAL"
>archive</TT
>水準を使用した場合にちょっとした計測可能な性能上の差異がありますので、実際に運用して問題が見つかった場合はご意見を聞かせてください。
       </P
></DD
><DT
><A
NAME="GUC-FSYNC"
></A
><TT
CLASS="VARNAME"
>fsync</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>       
	このパラメータがオンの場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバは<CODE
CLASS="FUNCTION"
>fsync()</CODE
>システム・コールを発行したり、もしくはこれに相当する方法で（<A
HREF="runtime-config-wal.html#GUC-WAL-SYNC-METHOD"
>wal_sync_method</A
>を参照）更新が物理的にディスクに書き込まれたかの確証を得ようと試みます。
	これは、オペレーティングシステムもしくはハードウェアがクラッシュした後、確実にデータベースクラスタを一貫した状態に復旧させることを保証します。
       </P
><P
>       
	<TT
CLASS="VARNAME"
>fsync</TT
>を停止することはしばしば性能上の利益になるとは言っても、予期せぬシステム停止やクラッシュの際に回復不可能なデータ破壊になることがあります。
	従って外部データから全てのデータベースを簡単に再構築できる場合のみ<TT
CLASS="VARNAME"
>fsync</TT
>を停止してください。
       </P
><P
>       
        <TT
CLASS="VARNAME"
>fsync</TT
>を停止しても安全な状況の例としては、以下があげられます。
        データベースが削除され、そして再構築されたデータの一群の処理のため、または頻繁に再構築され、かつフェイルオーバには使用されない読み取り専用のデータベースクローンに対し、バックアップファイルから新規データベースクラスタの初回読みを行う場合です。
       高性能なハードウェアであるからと言って、<TT
CLASS="VARNAME"
>fsync</TT
>を停止することは正当性を主張する十分な理由とはなりません。
       </P
><P
>       
	多くの場合、致命的ではないトランザクションにおいて<A
HREF="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT"
>synchronous_commit</A
>を無効にすることにより、データ破壊の付随的危険性を伴うことなく、<TT
CLASS="VARNAME"
>fsync</TT
>を無効にした場合に潜在する性能上のメリットの多くを得ることができます。
       </P
><P
>       
	<TT
CLASS="VARNAME"
>fsync</TT
> は<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
このパラメータを無効にする場合、<A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>も同時に無効にすることを検討してください。
       </P
></DD
><DT
><A
NAME="GUC-SYNCHRONOUS-COMMIT"
></A
><TT
CLASS="VARNAME"
>synchronous_commit</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)</DT
><DD
><P
>       
	トランザクションのコミットがクライアントに<SPAN
CLASS="QUOTE"
>"success"</SPAN
>の表示を返す前に、WALレコードがディスク上に書き込まれるまで待つかどうかの指定をします。
	有効な値は<TT
CLASS="LITERAL"
>on</TT
>、<TT
CLASS="LITERAL"
>local</TT
>、および<TT
CLASS="LITERAL"
>off</TT
>です。
デフォルトかつ安全な設定は<TT
CLASS="LITERAL"
>on</TT
>です。
<TT
CLASS="LITERAL"
>off</TT
>の場合、クライアントに成功を報告する時点とトランザクションが本当にサーバクラッシュに対して安全になるまでの間に遅延が発生します。
（最大の遅延は、<A
HREF="runtime-config-wal.html#GUC-WAL-WRITER-DELAY"
>wal_writer_delay</A
>の3倍です。）
<A
HREF="runtime-config-wal.html#GUC-FSYNC"
>fsync</A
>と異なり、このパラメータを<TT
CLASS="LITERAL"
>off</TT
>に設定することによって、データベースの一貫性が損なわれる可能性はありません。
オペレーティングシステムやデータベースのクラッシュにより最近コミットされたということになっているトランザクションの一部が失われる可能性がありますが、これらのトランザクションが正常にアボートされた時とデータベースの状態は変わりません。
ですので、<TT
CLASS="VARNAME"
>synchronous_commit</TT
>を無効にすることは、トランザクションの信頼性が確実であることよりも性能が重要である場合に有効な方法です。
詳細は<A
HREF="wal-async-commit.html"
>&#38917;29.3</A
>を参照してください。
       </P
><P
>       
	<A
HREF="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES"
>synchronous_standby_names</A
>が設定されていると、このパラメータもやはり、トランザクションのWALレコードがディスクにフラッシュされ、スタンバイサーバに複製されるまでトランザクションコミットを待機するか否かを制御します。
	コミットされたレコードが永続性のある記憶装置に既に書き込まれたことを現在実行中の同期スタンバイが確実視しない限りコミット待機は解除されません。
	同期レプリケーションが使用されている場合、通常、WALレコードがローカルとリモートディスクの両方に到達するか、またはトランザクションに非同期でコミットさせるかどちらかの選択を行うように実用的になっています。
	しかし、トランザクションに対し特別の値である<TT
CLASS="LITERAL"
>local</TT
>が使用でき、同期レプリケーションではなく、ディスクへのローカルフラッシュの待機を要請することが可能です。
       </P
><P
>       
	このパラメータはいつでも変更可能です。
この設定により任意の1つのトランザクションのコミット時の動作が決まります。
したがって、一部のトランザクションのコミットを同期的に、その他を非同期的にすることが可能で、かつ、有用です。
例えば、デフォルトが同期コミットの場合に単一の複数文トランザクションを非同期にコミットさせるためには、トランザクション内で<TT
CLASS="COMMAND"
>SET LOCAL synchronous_commit TO OFF</TT
>を発行します。
       </P
></DD
><DT
><A
NAME="GUC-WAL-SYNC-METHOD"
></A
><TT
CLASS="VARNAME"
>wal_sync_method</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)</DT
><DD
><P
>       
	WALの更新をディスクへ強制するのに使用される方法です。<TT
CLASS="VARNAME"
>fsync</TT
>がオフの場合この設定は役に立ちません。と言うのはWALファイルの更新が全く強制されないからです。取り得る値は以下のものです。
       </P
><P
></P
><UL
><LI
><P
>	
	 <TT
CLASS="LITERAL"
>open_datasync</TT
>（<CODE
CLASS="FUNCTION"
>open()</CODE
>オプション<TT
CLASS="SYMBOL"
>O_DSYNC</TT
>でWALファイルの書き込み）
        </P
></LI
><LI
><P
>	
	 <TT
CLASS="LITERAL"
>fdatasync</TT
>（コミット毎に<CODE
CLASS="FUNCTION"
>fdatasync()</CODE
>を呼び出し）
        </P
></LI
><LI
><P
>        
	 <TT
CLASS="LITERAL"
>fsync</TT
>（コミット毎に<CODE
CLASS="FUNCTION"
>fsync()</CODE
>を呼び出し）
        </P
></LI
><LI
><P
>	
	 <TT
CLASS="LITERAL"
>fsync_writethrough</TT
>（いかなるディスク書き込みキャッシュもライトスルーさせるため、コミット毎に<CODE
CLASS="FUNCTION"
>fsync()</CODE
>を呼び出し）
        </P
></LI
><LI
><P
>	
	 <TT
CLASS="LITERAL"
>open_sync</TT
>（<CODE
CLASS="FUNCTION"
>open()</CODE
>オプション<TT
CLASS="SYMBOL"
>O_SYNC</TT
>でWALファイルの書き込み）
        </P
></LI
></UL
><P
>       
	もし可能なら<TT
CLASS="LITERAL"
>open_</TT
>*オプションも<TT
CLASS="LITERAL"
>O_DIRECT</TT
>を使用します。
	全てのプラットホームでこれら全ての選択肢が使えるわけではありません。
デフォルトは、上のリストのプラットフォームでサポートされるものの最初に列挙されているものです。ただしLinuxでは<TT
CLASS="LITERAL"
>fdatasync</TT
>がデフォルトです。
　　　　デフォルトは必ずしも理想的なものではありません。
　　　　この設定、あるいはクラッシュに適応した構成か、アーカイブの最適性能を導くために使用しているシステム構成の形態を変更することが必要かもしれません。
これらの側面は<A
HREF="wal-reliability.html"
>&#38917;29.1</A
>で解説されます。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-FULL-PAGE-WRITES"
></A
><TT
CLASS="VARNAME"
>full_page_writes</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>       
	このパラメータが有効の場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバは、チェックポイントの後にそのページが最初に変更された過程で、ディスクページの全ての内容をWALに書き込みます。
オペレーティングシステムがクラッシュした時に進行中のページ書き込みは途中までしか終わっていない可能性があるため、これが必要です。
この場合、ディスク上のページは古いデータと新しいデータが混在する状態になります。
通常WAL内に保存される行レベルの変更データは、クラッシュ後のリカバリ時にこうしたページを完全に復旧させるには不十分です。
完全なページイメージが、ページを正確に復旧できることを保証します。
しかし、WALに書き込まなければならないデータ量が増加する代償と引きかえになります。
（WAL再生は常にチェックポイントから始まるため、チェックポイント後のそれぞれのページの最初の変更時にこれを行うことで差し支えありません。
従って、完全ページ書き出しのコストを低減する方法の1つは、チェックポイント間隔パラメータを増やすことです。）
       </P
><P
>       
	このパラメータを無効にすると、通常の操作速度が上がりますが、システム障害後に、回復不能なデータ破損、あるいは警告なしのデータ損壊をもたらすかもしれません。
このリスクは小さいながら<TT
CLASS="VARNAME"
>fsync</TT
>を無効にした場合と似ています。そしてその<TT
CLASS="VARNAME"
>fsync</TT
>に対して推奨されている同一の状況に基づく限りにおいて停止されなければなりません。
       </P
><P
>       
	このパラメータを無効にしてもポイントインタイムリカバリ（PITR）用のWALアーカイブの使用に影響ありません（ <A
HREF="continuous-archiving.html"
>&#38917;24.3</A
>を参照してください）。
       </P
><P
>       
	このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル内、または、サーバのコマンドラインでのみ設定可能です。
デフォルトは<TT
CLASS="LITERAL"
>on</TT
>です。
       </P
></DD
><DT
><A
NAME="GUC-WAL-BUFFERS"
></A
><TT
CLASS="VARNAME"
>wal_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	未だディスクに書き込まれていないWALデータに対して使用される共有メモリ容量です。
	デフォルトの設定である-1は、<A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
>shared_buffers</A
>の1/32（約3%）の容量に等しい大きさを選択します。
	しかし、<TT
CLASS="LITERAL"
>64kB</TT
>未満ではなく、かつ典型的に<TT
CLASS="LITERAL"
>16MB</TT
>であるWALセグメントの大きさを越えることはありません。
	もし、自動設定による選択が大きすぎたり、小さすぎる場合この値は手作業で設定可能です。
	しかし、<TT
CLASS="LITERAL"
>32kB</TT
>未満のどんな正の値であっても、<TT
CLASS="LITERAL"
>32kB</TT
>として取り扱われます。
　　　　このパラメータはサーバ起動時のみ設定可能です。
       </P
><P
>       
	WALバッファの内容はトランザクションのコミット毎にディスクに書き込まれます。
	したがって、極端に大きな値は有意な効果を期待できません。
	しかし、この値を数メガバイトに設定することにより、多くのクライアントが同時にコミットするトラフィック量の多いサーバでは書き込み性能が向上します。
	デフォルト設定の-1で選択される自動チューニングによると、ほとんどの場合妥当な結果が得られます。
       </P
><P
>       
	このパラメータを増加させると、使用しているオペレーティングシステムのデフォルト構成が許容する<SPAN
CLASS="SYSTEMITEM"
>System V</SPAN
>共有メモリの限界を越えた要求を<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が行う原因となることがあります。必要であれば、どの様にしてこのパラメータを調整するかについて<A
HREF="kernel-resources.html#SYSVIPC"
>&#38917;17.4.1</A
>を参照ください。 
       </P
></DD
><DT
><A
NAME="GUC-WAL-WRITER-DELAY"
></A
><TT
CLASS="VARNAME"
>wal_writer_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	WALライタの活動周期の間隔を指定します。
ライタのこの各周期でWALをディスクに吐き出します。
そして<TT
CLASS="VARNAME"
>wal_writer_delay</TT
>ミリ秒待機し、それを繰り返します。
デフォルト値は200ミリ秒（<TT
CLASS="LITERAL"
>200ms</TT
>）です。
多くのシステムでは、待機間隔の実質的な分解能は10ミリ秒です。
10の倍数以外の値を<TT
CLASS="VARNAME"
>wal_writer_delay</TT
>に設定しても、その次に大きい10の倍数を設定した場合と同じ結果となります。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル内またはサーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-COMMIT-DELAY"
></A
><TT
CLASS="VARNAME"
>commit_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	トランザクションに対するコミットデータがディスクにフラッシュされた時、その時点において用意万端のいかなる追加的コミットも同じくフラッシュされます。
	マイクロ秒単位で設定される<TT
CLASS="VARNAME"
>commit_delay</TT
>は、トランザクションがWALバッファをディスクにフラッシュを試みる前までの時間遅延を追加します。
	システム負荷が充分に高く、指定期間内にコミット準備ができる他のトランザクションが存在しない場合、非ゼロの遅延時間で複数のトランザクションを一度のフラッシュ操作で行えるようになります。
　　　　しかし、もし他のトランザクションがコミットできる状態にならなければ、この遅延は無駄になります。と言うことは、サーバプロセスがそのコミットレコードを書き込んだ瞬間に他のトランザクションが進行している <TT
CLASS="VARNAME"
>commit_siblings</TT
>にだけ少なくとも実行されます。
	デフォルトの <TT
CLASS="VARNAME"
>commit_delay</TT
> はゼロ（遅延無し）です。
	この設定にかかわらず、全ての保留中のコミットデータはそれぞれのフラッシュの際に書き込まれるので、このパラメータを大きくして遅延を追加しても実際に性能が向上することは稀にしか起こりません。
	</P
></DD
><DT
><A
NAME="GUC-COMMIT-SIBLINGS"
></A
><TT
CLASS="VARNAME"
>commit_siblings</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	<TT
CLASS="VARNAME"
>commit_delay</TT
>遅延を実行する前に必要とされる同時に開いているトランザクションの最小数です。
より大きい値は、遅延周期の間に、少なくとも1つの他のトランザクションがコミットの準備を整わせることを確実にします。
デフォルトは5トランザクションです。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-CHECKPOINTS"
>18.5.2. チェックポイント</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-CHECKPOINT-SEGMENTS"
></A
><TT
CLASS="VARNAME"
>checkpoint_segments</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	自動WALチェックポイント間の最大ログファイル数です。（それぞれのセグメントは通常16メガバイト）
デフォルトは3セグメントです。
このパラメータを増やすと、クラッシュリカバリで必要となる時間が増加します。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	自動的WALチェックポイント間の最大間隔を秒単位で指定します。
デフォルトは5分（<TT
CLASS="LITERAL"
>5min</TT
>）です。
このパラメータを増やすと、クラッシュリカバリで必要となる時間が増加します。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-COMPLETION-TARGET"
></A
><TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>)</DT
><DD
><P
>       
	チェックポイントの完了目標をチェックポイント間の総時間の割合として指定します。
デフォルトは0.5です。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-WARNING"
></A
><TT
CLASS="VARNAME"
>checkpoint_warning</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	チェックポイントセグメントファイルが溢れることが原因で起きるチェックポイントが、ここで指定した秒数よりも頻繁に発生する場合、サーバログにメッセージを書き出します
（これは、<TT
CLASS="VARNAME"
>checkpoint_segments</TT
>を増やす必要があることを示唆しています）。
デフォルトは30秒（<TT
CLASS="LITERAL"
>30s</TT
>）です。
零の場合は警告を出しません。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-ARCHIVING"
>18.5.3. アーカイビング</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-ARCHIVE-MODE"
></A
><TT
CLASS="VARNAME"
>archive_mode</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)</DT
><DD
><P
>       
	<TT
CLASS="VARNAME"
>archive_mode</TT
>が有効な時、<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>を設定して、完了したWALセグメントをアーカイブ格納領域に送信されます。
アーカイブモードを抜けることなく<TT
CLASS="VARNAME"
>archive_command</TT
>を変更できるように、<TT
CLASS="VARNAME"
>archive_mode</TT
>と<TT
CLASS="VARNAME"
>archive_command</TT
>は分離されました。
このパラメータはサーバ起動時のみ設定可能です。
　　　　<TT
CLASS="VARNAME"
>wal_level</TT
> が <TT
CLASS="LITERAL"
>minimal</TT
>に設定されている場合、<TT
CLASS="VARNAME"
>archive_mode</TT
>は有効になりません。
       </P
></DD
><DT
><A
NAME="GUC-ARCHIVE-COMMAND"
></A
><TT
CLASS="VARNAME"
>archive_command</TT
> (<TT
CLASS="TYPE"
>string</TT
>)</DT
><DD
><P
>       
	完了したWALファイルセグメントのアーカイブを実行するシェルコマンドです。
文字列内のいかなる<TT
CLASS="LITERAL"
>%p</TT
>は、格納されるファイルの絶対パスで置き換えられ、そして、<TT
CLASS="LITERAL"
>%f</TT
>はファイル名のみ置換します。
（このパス名はサーバの作業用ディレクトリ、つまり、クラスタのデータディレクトリからの相対パスです。）
コマンド内で実際の<TT
CLASS="LITERAL"
>%</TT
>文字を埋め込むには<TT
CLASS="LITERAL"
>%%</TT
>を使用します。
コマンドが成功した場合に限って終了ステータスゼロを返すことが重要です。
より詳しくは<A
HREF="continuous-archiving.html#BACKUP-ARCHIVING-WAL"
>&#38917;24.3.1</A
>を参照ください。
       </P
><P
>       
	このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
サーバ起動時に<TT
CLASS="VARNAME"
>archive_mode</TT
>が有効でなければ、これは無視されます。
<TT
CLASS="VARNAME"
>archive_command</TT
>が空文字列（デフォルト）、かつ、<TT
CLASS="VARNAME"
>archive_mode</TT
>が有効な場合、WALアーカイブ処理は一時的に無効になりますが、コマンドが後で提供されることを見越して、サーバはWALセグメントの蓄積を続けます。
例えば、<TT
CLASS="LITERAL"
>/bin/true</TT
>（Windowsでは<TT
CLASS="LITERAL"
>REM</TT
>）のように、コマンドに対し<TT
CLASS="VARNAME"
>archive_command</TT
>を真を返すだけで何もしないように設定すると効果的にアーカイブ処理を無効にしますが、アーカイブからの復帰に必要なWALファイルの連鎖を同時に断ち切ります。従って、特別な場合のみ使用するようにしなければなりません。
       </P
></DD
><DT
><A
NAME="GUC-ARCHIVE-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>archive_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)</DT
><DD
><P
>       
	<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>は完了したWALセグメントに対してのみ呼び出されます。従って、サーバのWAL転送量が少ししかない（処理を行わないなぎの期間がある）場合、トランザクションの完了とアーカイブ格納領域への安全な記録との間に長期にわたる遅延があることになります。
古い未アーカイブのデータをどうするかについて制限を付けるために、<TT
CLASS="VARNAME"
>archive_timeout</TT
>を設定して、強制的にサーバを新しいWALセグメントに定期的に切り替えるようにすることができます。
このパラメータが0より大きければ、サーバは前回のセグメントファイル切り替えから指定秒数経過した場合、および単一のチェックポイントを含む何らかのデータベース操作が行われた場合、新しいセグメントファイルに切り替えます。（<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>を大きくすると待機状態のシステム上のなくてもいいチェックポイントを削減します。）
強制切り替えにより早期に閉ざされたアーカイブ済みファイルは完全に完了したファイルと同じ大きさを持つことに注意してください。
そのため、非常に小さな<TT
CLASS="VARNAME"
>archive_timeout</TT
>を使用することは思慮を欠いています。
格納領域を膨張させてしまいます。
通常１分程度の<TT
CLASS="VARNAME"
>archive_timeout</TT
>設定が妥当です。
　　　　もしそれより高速にデータをマスターサーバにコピーをしてしまいたいのであれば、アーカイブするよりストリーミングレプリケーションの選択を検討すべきです。
このパラメータは <TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみで設定可能です。
       </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>資源の消費</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>レプリケーション</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
