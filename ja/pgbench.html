<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>pgbench</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="追加で提供されるモジュール"
HREF="contrib.html"><LINK
REL="PREVIOUS"
TITLE="pg_archivecleanup"
HREF="pgarchivecleanup.html"><LINK
REL="NEXT"
TITLE="pg_buffercache"
HREF="pgbuffercache.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="SECT1"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="pg_archivecleanup"
HREF="pgarchivecleanup.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="追加で提供されるモジュール"
HREF="contrib.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#20184;&#37682; F. 追加で提供されるモジュール</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="追加で提供されるモジュール"
HREF="contrib.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="pg_buffercache"
HREF="pgbuffercache.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PGBENCH"
>F.26. pgbench</A
></H1
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>上でベンチマーク試験を行う単純なプログラムです。
これは同一のSQLコマンドの並びを何度も実行します。複数の同時実行データベースセッションで実行することもできます。
そして、トランザクションの速度（1秒当たりのトランザクション数）の平均を計算します。
デフォルトで<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は、1トランザクション当たり5つの<TT
CLASS="COMMAND"
>SELECT</TT
>、<TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>INSERT</TT
>コマンドを含むおおよそTPC-Bに基いたシナリオを試験します。
しかし、独自のトランザクションスクリプトファイルを作成することで他の試験ケースを簡単に実行することができます。
 </P
><P
>pgbenchの典型的な出力を以下に示します。

</P><PRE
CLASS="SCREEN"
>transaction type: TPC-B (sort of)
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)</PRE
><P>

最初の6行はいくつかの最重要パラメータの設定を表示しています。
次行が完了トランザクション数と予定トランザクション数です（後者は単なるクライアント数とクライアント毎のトランザクション数の積算結果です。）
実行が完了する前に失敗しない限りこれは等しくなります。
(<TT
CLASS="LITERAL"
>-T</TT
>モードでは、トランザクションの実際の数が表示されます)
最後の2行は、データベースセッションを開始するための時間を含める場合と含めない場合の1秒当たりのトランザクション数を示します。
 </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN135110"
>F.26.1. 概要</A
></H2
><P
>デフォルトのTPC-Bと似たトランザクション試験では、あらかじめ設定する特定のテーブルが必要です。
これらのテーブルを作成し、データを投入するためには、<TT
CLASS="LITERAL"
>-i</TT
>(初期化)オプションを付けて<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>を呼び出さなければなりません。
(独自スクリプトを試験する場合、この手順は必要ありません。
しかし代わりに試験に必要な何らかの設定を行わなければならないでしょう。)
初期化は以下のようになります。

</P><PRE
CLASS="PROGRAMLISTING"
>pgbench -i [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>other-options</I
></TT
> </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>

ここで<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
>は試験用に前もって作成されたデータベースの名前です。
（またデータベースサーバの接続方法を指定するために、<TT
CLASS="LITERAL"
>-h</TT
>、<TT
CLASS="LITERAL"
>-p</TT
>、<TT
CLASS="LITERAL"
>-U</TT
>が必要になるかもしれません。）
  </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>&#27880;&#24847;</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
><TT
CLASS="LITERAL"
>pgbench -i</TT
>は4つのテーブル<TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_history</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>を作成します。
もしあればこうした名前のテーブルは破壊されます。
もし同じ名前のテーブルが存在する場合にはよく注意してください。
   </P
></TD
></TR
></TABLE
></DIV
><P
>デフォルトの<SPAN
CLASS="QUOTE"
>"倍数"</SPAN
>の1では、テーブルは初期状態で以下の行数を含みます。
</P><PRE
CLASS="SCREEN"
>table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0</PRE
><P>
<TT
CLASS="LITERAL"
>-s</TT
>（倍数）オプションを使用して行数を増加させることができます（また、ほとんどの目的ではおそらく増加させるべきです）。
また、<TT
CLASS="LITERAL"
>-F</TT
> （フィルファクタ）オプションをここで使用しても構いません。
  </P
><P
>一度この必要な設定を行った後、以下のように<TT
CLASS="LITERAL"
>-i</TT
>を持たないコマンドでベンチマークを行うことができます。

</P><PRE
CLASS="PROGRAMLISTING"
>pgbench [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
> </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>

ほとんどすべての場合、有用な試験とするためにいくつかのオプションが必要になります。
最重要オプションは<TT
CLASS="LITERAL"
>-c</TT
>（クライアント数）、<TT
CLASS="LITERAL"
>-t</TT
>（トランザクション数）、<TT
CLASS="LITERAL"
>-T</TT
> (制限時間)
<TT
CLASS="LITERAL"
>-f</TT
>（独自スクリプトファイルの指定）です。
以下の全一覧を参照してください。
  </P
><P
><A
HREF="pgbench.html#PGBENCH-INIT-OPTIONS"
>&#38917;F.26.2</A
>はデータベース初期化時に使用されるオプションを示します。
<A
HREF="pgbench.html#PGBENCH-RUN-OPTIONS"
>&#38917;F.26.3</A
>はベンチマーク実行時に使用されるオプションを示します。
そして、<A
HREF="pgbench.html#PGBENCH-COMMON-OPTIONS"
>&#38917;F.26.4</A
>はどちらの場合でも使用されるオプションを示します。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PGBENCH-INIT-OPTIONS"
>F.26.2. <SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>初期化オプション</A
></H2
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は以下の初期化用のコマンドライン引数を受け付けます。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-i</TT
></DT
><DD
><P
>初期化モードを呼び出すために必要です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-F</TT
> <TT
CLASS="REPLACEABLE"
><I
>fillfactor</I
></TT
></DT
><DD
><P
>指定したフィルファクタで<TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルを作成します。
デフォルトは100です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
> <TT
CLASS="REPLACEABLE"
><I
>scale_factor</I
></TT
></DT
><DD
><P
>この倍率で生成される行数を積算します。
例えば、<TT
CLASS="LITERAL"
>-s 100</TT
>は <TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>テーブルに10,000,000行を生成することを意味します。
デフォルトは1です。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PGBENCH-RUN-OPTIONS"
>F.26.3. <SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>ベンチマーク用オプション</A
></H2
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は以下のベンチマーク用コマンドライン引数を受け付けます。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-c</TT
> <TT
CLASS="REPLACEABLE"
><I
>clients</I
></TT
></DT
><DD
><P
>模擬するクライアント数、つまり、同時に実行されるデータベースセッション数です。
デフォルトは1です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-C</TT
></DT
><DD
><P
>各クライアントセッションが一度だけ接続を確立するのではなく、各トランザクションが新しい接続を確立します。
これは接続オーバーヘッドを測定する場合に有用です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-d</TT
></DT
><DD
><P
>デバッグ用出力を表示します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-D</TT
> <TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
><TT
CLASS="LITERAL"
>=</TT
><TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
></DT
><DD
><P
>独自スクリプト（後述）で使用される変数を定義します。
複数の<TT
CLASS="LITERAL"
>-D</TT
>オプションを使用することができます。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-f</TT
> <TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
></DT
><DD
><P
>トランザクションスクリプトを<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>から読み取ります。
詳細は後で説明します。
<TT
CLASS="LITERAL"
>-N</TT
>、<TT
CLASS="LITERAL"
>-S</TT
>、<TT
CLASS="LITERAL"
>-f</TT
>は互いに排他的です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-j</TT
> <TT
CLASS="REPLACEABLE"
><I
>threads</I
></TT
></DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>内のワーカスレッド数です。
複数のスレッドを使用することはマルチCPUマシンで有用になります。
各スレッドには管理するクライアントセッションを同じ数与えられますので、クライアント数はスレッド数の倍数でなければなりません。
デフォルトは1です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-l</TT
></DT
><DD
><P
>各トランザクションで費やした時間をログファイルに書き出します。
後で詳細を説明します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-M</TT
> <TT
CLASS="REPLACEABLE"
><I
>querymode</I
></TT
></DT
><DD
><P
>サーバへ問い合わせを送信するために使用するプロトコルです。
          <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>simple</TT
>: 簡易問い合わせプロトコルを使用します。</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>extended</TT
>: 拡張問い合わせプロトコルを使用します。</P
></LI
><LI
><P
>プリペアドステートメントを伴う拡張問い合わせプロトコルを使用します。</P
></LI
></UL
><P>
デフォルトは簡易問い合わせプロトコルです。
（詳しい情報は<A
HREF="protocol.html"
>&#31532;46&#31456;</A
>を参照してください）
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-n</TT
></DT
><DD
><P
>試験を実行する前にバキュームを行いません。
<TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_history</TT
>、 <TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>標準テーブルを含まない独自試験シナリオを実行する場合、このオプションは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>必要</I
></SPAN
>です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-N</TT
></DT
><DD
><P
><TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>と<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>を更新しません。
これは両テーブル上の重度の更新の競合を防ぎますが、TPC-Bのような試験ケースを行わなくなります。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-r</TT
></DT
><DD
><P
>ベンチマーク完了後の各コマンドにおけるステートメント毎の平均レイテンシ(クライアントから見た実行時間)を報告します。詳しくは下を参照してください。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
> <TT
CLASS="REPLACEABLE"
><I
>scale_factor</I
></TT
></DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>の出力で指定した倍率を報告します。
これは組み込みの試験では必要ありません。
正確な倍率が<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルの行数を数えることで検出されます。
しかし、独自ベンチマーク（<TT
CLASS="LITERAL"
>-f</TT
>オプション）を試験している場合、このオプションを使用しない限り、倍率は1として報告されます。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-S</TT
></DT
><DD
><P
>TPC-Bのような試験ではなく読み取りのみのトランザクションを実行します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
> <TT
CLASS="REPLACEABLE"
><I
>transactions</I
></TT
></DT
><DD
><P
>各クライアントが実行するトランザクション数です。
デフォルトは10です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-T</TT
> <TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
></DT
><DD
><P
>クライアントあたりのトランザクション数を固定で指定するよりも長くテストを実行したい場合、ここに指定した秒数でテストを実行します。
<TT
CLASS="LITERAL"
>-t</TT
>と<TT
CLASS="LITERAL"
>-T</TT
>は互いに排他的です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-v</TT
></DT
><DD
><P
>試験前に4つの標準テーブルすべてをバキュームを行います。
<TT
CLASS="LITERAL"
>-n</TT
>も<TT
CLASS="LITERAL"
>-v</TT
>もなければ、pgbenchは<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>と<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルをバキュームし、<TT
CLASS="STRUCTNAME"
>pgbench_history</TT
>内のデータをすべて消去します。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PGBENCH-COMMON-OPTIONS"
>F.26.4. <SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>共通オプション</A
></H2
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は以下の共通コマンドライン引数を受け付けます。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-h</TT
> <TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
></DT
><DD
><P
>      データベースサーバのホスト
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-p</TT
> <TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
></DT
><DD
><P
>データベースサーバのポート
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-U</TT
> <TT
CLASS="REPLACEABLE"
><I
>login</I
></TT
></DT
><DD
><P
>      接続ユーザ名
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN135330"
>F.26.5. pgbenchで実際に実行される<SPAN
CLASS="QUOTE"
>"トランザクション"</SPAN
>は何か?</A
></H2
><P
>デフォルトのトランザクションスクリプトは、1トランザクションで以下の7コマンドを発行します。
  </P
><P
></P
><OL
TYPE="1"
><LI
><P
><TT
CLASS="LITERAL"
>BEGIN;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>END;</TT
></P
></LI
></OL
><P
><TT
CLASS="LITERAL"
>-N</TT
>を指定した場合、第4コマンドと第5コマンドはトランザクションに含まれません。
<TT
CLASS="LITERAL"
>-S</TT
>を指定した場合、<TT
CLASS="COMMAND"
>SELECT</TT
>のみが発行されます。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN135360"
>F.26.6. 独自スクリプト</A
></H2
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は、ファイルから読み込んだトランザクションスクリプト（<TT
CLASS="LITERAL"
>-f</TT
>オプション）でデフォルトのトランザクションスクリプト（上述）を置き換えて独自のベンチマークシナリオを実行する機能をサポートします。
この場合、<SPAN
CLASS="QUOTE"
>"トランザクション"</SPAN
>はスクリプトファイルの1回の実行として数えられます。
複数のスクリプトを指定する（複数の<TT
CLASS="LITERAL"
>-f</TT
>オプション）ことさえ可能です。
この場合、クライアントセッションが新しいトランザクションを開始する時にランダムにスクリプトの1つが選択されます。
  </P
><P
>スクリプトファイルの書式は、1行1 SQLコマンドという形で、複数行に跨るSQLコマンドはサポートされません。
空行および<TT
CLASS="LITERAL"
>--</TT
>から始まる行は無視されます。
スクリプトファイルの行には、<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>自身が解釈する<SPAN
CLASS="QUOTE"
>"メタコマンド"</SPAN
>（後述）も記述することができます。
  </P
><P
>スクリプトファイル向けの簡単な変数置換機能があります。
上で説明したように変数を<TT
CLASS="LITERAL"
>-D</TT
>コマンドラインオプションで設定することができます。
また、後で説明するようにメタコマンドで設定することもできます。
<TT
CLASS="LITERAL"
>-D</TT
>コマンドラインオプションで設定された変数の他に、<TT
CLASS="LITERAL"
>scale</TT
>変数は現在の倍率に設定されています。
一度設定すると、<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>と記述することで変数の値はSQLコマンドに挿入されます。
1つ以上のクライアントセッションを実行する時、セッション毎に独自の変数群を持ちます。
  </P
><P
>スクリプトファイルメタコマンドはバックスラッシュ（<TT
CLASS="LITERAL"
>\</TT
>）から始まります。
メタコマンドへの引数は空白文字で区切られます。
以下のメタコマンドがサポートされています。
  </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>\set <TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operand1</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operand2</I
></TT
> ]</TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
>変数を計算された整数値に設定します。
各<TT
CLASS="REPLACEABLE"
><I
>operand</I
></TT
>は整数定数か整数値を持つ変数への<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>参照のいずれかです。
<TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
>は<TT
CLASS="LITERAL"
>+</TT
>、<TT
CLASS="LITERAL"
>-</TT
>、<TT
CLASS="LITERAL"
>*</TT
>、<TT
CLASS="LITERAL"
>/</TT
>を取ることができます。
     </P
><P
>例
</P><PRE
CLASS="PROGRAMLISTING"
>\set ntellers 10 * :scale</PRE
><P>
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>\setrandom <TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>min</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>max</I
></TT
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
>変数を<TT
CLASS="REPLACEABLE"
><I
>min</I
></TT
>から<TT
CLASS="REPLACEABLE"
><I
>max</I
></TT
>までの範囲のランダムな整数値に設定します。
各制限は整数定数か整数値を持つ変数への<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>参照のいずれかです。
     </P
><P
>例
</P><PRE
CLASS="PROGRAMLISTING"
>\setrandom aid 1 :naccounts</PRE
><P>
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>\sleep <TT
CLASS="REPLACEABLE"
><I
>number</I
></TT
> [ us | ms | s ]</TT
></DT
><DD
><P
>スクリプトの実行をマイクロ秒（<TT
CLASS="LITERAL"
>us</TT
>）、ミリ秒（<TT
CLASS="LITERAL"
>ms</TT
>）、秒（<TT
CLASS="LITERAL"
>s</TT
>）単位で指定した間待機させます。
単位を省略した場合、デフォルトは秒です。
<TT
CLASS="REPLACEABLE"
><I
>number</I
></TT
>は整数定数か整数値を持つ変数への<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>参照のいずれかです。
     </P
><P
>例
</P><PRE
CLASS="PROGRAMLISTING"
>\sleep 10 ms</PRE
><P>
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>\setshell <TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> ... ]</TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>シェルコマンドの結果を<TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
>変数に設定します。
このコマンドは標準出力を通して整数値を返さなければなりません。
     </P
><P
><TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>は、テキスト定数または任意の型の変数を参照する<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>とすることができます。
コロンから始まる<TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>を使用したい場合、<TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>の先頭にさらにコロンを付けなければなりません。
     </P
><P
>例:
</P><PRE
CLASS="PROGRAMLISTING"
>\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon</PRE
><P>
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>\shell <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> ... ]</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>\setshell</TT
>と同じですが、結果は無視されます。
     </P
><P
>例:
</P><PRE
CLASS="PROGRAMLISTING"
>\shell command literal_argument :variable ::literal_starting_with_colon</PRE
><P>
     </P
></DD
></DL
></DIV
><P
>例えば、組込みのTPC-Bのようなトランザクションの完全な定義を示します。

</P><PRE
CLASS="PROGRAMLISTING"
>\set nbranches :scale
\set ntellers 10 * :scale
\set naccounts 100000 * :scale
\setrandom aid 1 :naccounts
\setrandom bid 1 :nbranches
\setrandom tid 1 :ntellers
\setrandom delta -5000 5000
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;</PRE
><P>

 このスクリプトにより、トランザクションを繰り返す度に異なる、ランダムに選ばれた行を参照することができます。
 （この例はまた、各クライアントセッションがなぜ独自の変数を持つことが重要なのかも表しています。
 これがないと、異なる行を独立して参照することができないのです。）
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN135459"
>F.26.7. トランザクション毎のログ処理</A
></H2
><P
><TT
CLASS="LITERAL"
>-l</TT
>オプションを使用すると、<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は各トランザクションで要した時間をログファイルに書き出します。
ログファイルの名前は<TT
CLASS="FILENAME"
>pgbench_log.<TT
CLASS="REPLACEABLE"
><I
>nnn</I
></TT
></TT
>です。
ここで<TT
CLASS="REPLACEABLE"
><I
>nnn</I
></TT
>はpgbenchプロセスのPIDです。
<TT
CLASS="LITERAL"
>-j</TT
>オプションが2以上の場合、それぞれ独自のログファイルを持つ複数のワーカスレッドが生成されます。
最初のワーカは標準的な単一ワーカの場合と同じ名前を持つログファイルを使用します。
他のワーカ用の追加のログファイルは<TT
CLASS="FILENAME"
>pgbench_log.<TT
CLASS="REPLACEABLE"
><I
>nnn</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>mmm</I
></TT
></TT
>のように命名されます。
ここで<TT
CLASS="REPLACEABLE"
><I
>mmm</I
></TT
>は1から始まる各ワーカの連番です。
  </P
><P
>ログの書式は以下の通りです。

</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>client_id</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>transaction_no</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>file_no</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time_epoch</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time_us</I
></TT
></PRE
><P>

ここで<TT
CLASS="REPLACEABLE"
><I
>time</I
></TT
>はマイクロ秒単位の総トランザクション処理時間、<TT
CLASS="REPLACEABLE"
><I
>file_no</I
></TT
>は使用されたスクリプトファイルを識別するもの（<TT
CLASS="LITERAL"
>-f</TT
>により複数のスクリプトが指定された場合に有用）、<TT
CLASS="REPLACEABLE"
><I
>time_epoch</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>time_us</I
></TT
>はマイクロ秒のオフセットを持つUNIXエポック書式のタイムスタンプ（秒部分付きのISO 8601タイムスタンプの作成に適します）でトランザクションの完了時刻を示します。
  </P
><P
>以下に出力例を示します。
</P><PRE
CLASS="SCREEN"
> 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663</PRE
><P>
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN135487"
>F.26.8. ステートメント毎のレイテンシ</A
></H2
><P
><TT
CLASS="LITERAL"
>-r</TT
>オプションを付けると、<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は各クライアントにより実行されたトランザクションのステートメント毎の経過時間を収集します。
ベンチマークが終了した後、各値の平均値(各ステートメントのレイテンシと呼びます)が報告されます。
  </P
><P
>標準スクリプトでは、次のような出力になります。
</P><PRE
CLASS="SCREEN"
>starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
        0.004386        \set nbranches 1 * :scale
        0.001343        \set ntellers 10 * :scale
        0.001212        \set naccounts 100000 * :scale
        0.001310        \setrandom aid 1 :naccounts
        0.001073        \setrandom bid 1 :nbranches
        0.001005        \setrandom tid 1 :ntellers
        0.001078        \setrandom delta -5000 5000
        0.326152        BEGIN;
        0.603376        UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454643        SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528491        UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335435        UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371851        INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212976        END;</PRE
><P>
  </P
><P
>複数のスクリプトファイルが定義された場合、平均値はそれぞれのスクリプトファイル毎に分けて報告されます。
  </P
><P
>ステートメント毎のレイテンシを計算するために必要となる、追加のタイミング情報を収集することは、オーバーヘッドが加わることに注意してください。
これは平均実行速度を遅くし、計測TPSを小さくするでしょう。
低下量はプラットフォームとハードウェアに依存して著しく変わります。

レイテンシの報告を有効にする、有効にしないで平均TPS値を比較することは、タイミング・オーバーヘッドが顕著かどうかを測定するには良い方法です。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN135496"
>F.26.9. 優れた実践</A
></H2
><P
>まったく無意味な数値を生み出すように<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>を使用することは非常に簡単です。
以下に有意な結果を生み出す手助けとなるガイドラインをいくつか示します。
  </P
><P
>まず第一に、数秒で終わる試験を<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>決して</I
></SPAN
>信用しないでください。
<TT
CLASS="LITERAL"
>-t</TT
>または<TT
CLASS="LITERAL"
>-T</TT
>オプションを使って、雑音を取り除くために、少なくとも数分試験にかかるようにしてください。
再現可能な数値を得るために数時間必要になる場合もあります。
数回試験を繰り返し、数値が再現できるかどうか確認することを勧めます。
  </P
><P
>デフォルトのTPC-Bのような試験シナリオでは、初期倍率（<TT
CLASS="LITERAL"
>-s</TT
>）を試験予定のクライアント数（<TT
CLASS="LITERAL"
>-c</TT
>）の最大値と同程度にしなければなりません。
<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルには<TT
CLASS="LITERAL"
>-s</TT
>行しかありません。
また、前トランザクションはその内の1つを更新しようとします。
ですので、<TT
CLASS="LITERAL"
>-c</TT
>値を<TT
CLASS="LITERAL"
>-s</TT
>より大きくすると、他のトランザクションを待機するためにブロックされるトランザクションが多くなることは間違いありません。
  </P
><P
>デフォルトの試験シナリオはまた、テーブルを初期化してからの経過時間に非常に敏感です。
テーブル内の不要行や不要空間の累積により結果が変わります。
結果を理解するためには、更新された行数とバキューム時期を把握する必要があります。
自動バキュームが有効な場合、性能を測定する上で結果は予測できないほど変わる可能性があります。
  </P
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>の制限は、多くのクライアントセッションを試験しようとする際に<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>自身がボトルネックになる可能性があることです。
これは、データベースサーバとは別のマシンで<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>を実行することで緩和させることが可能です。
しかし、多少のネットワーク遅延が重要です。
同一データベースサーバに対し複数のクライアントマシンから複数の<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>インスタンスを同時に実行することが有用かもしれません。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="pgarchivecleanup.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="pgbuffercache.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>pg_archivecleanup</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="contrib.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>pg_buffercache</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
