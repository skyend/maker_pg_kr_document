<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>TOAST</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version "><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.1.4文書"
HREF="index.html"><LINK
REL="UP"
TITLE="データベースの物理的な格納"
HREF="storage.html"><LINK
REL="PREVIOUS"
TITLE="データベースファイルのレイアウト"
HREF="storage-file-layout.html"><LINK
REL="NEXT"
TITLE="空き領域マップ"
HREF="storage-fsm.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=euc-jp"><META
NAME="creation"
CONTENT="2012-06-16T03:12:10"></HEAD
><BODY
CLASS="SECT1"
><script type="text/javascript">
var mod_layout = 'test';
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-50659-6");
pageTracker._trackPageview();
</script>
<style>
body{margin:0;}
#lay_body{margin:8px;}
#lay_header{margin:0 0 4px 0;border:0;padding:0;}
#lay_header .b1{border-bottom:#cef solid 1px;}
#lay_header .b2{border-bottom:#8df solid 1px;}
#lay_header .b3{border-bottom:#4bf solid 1px;padding:5px 5px 3px 5px;background:#0af;text-align:center;color:#fff;}
#lay_header a{text-decoration:none;color:#fff;font-weight:bold;}
#lay_header a:hover{text-decoration:underline;}
</style>
<div id="lay_header"><div class="b1"><div class="b2"><div class="b3">
<a href="http://lets.postgresql.jp/" target="_blank">PostgreSQLポータルサイト ＜Let's Postgres＞ http://lets.postgresql.jp/</a><br>
入門から運用、チューニングノウハウ、新機能の解説など、幅広い内容の技術解説記事をお読みいただけます。
</div></div></div></div>
<div id="lay_body">
<DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="5"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.1.4文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="データベースファイルのレイアウト"
HREF="storage-file-layout.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="データベースの物理的な格納"
HREF="storage.html"
>&#24059;&#25147;&#12375;</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>&#31532; 55&#31456;データベースの物理的な格納</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="データベースの物理的な格納"
HREF="storage.html"
>&#26089;&#36865;&#12426;</A
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="top"
><A
TITLE="空き領域マップ"
HREF="storage-fsm.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STORAGE-TOAST"
>55.2. TOAST</A
></H1
><P
>本節では<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>（過大属性格納技法：The Oversized-Attribute Storage Technique）の概要について説明します。</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は固定長のページサイズ（通常8キロバイト）を使用し、複数ページにまたがるタプルを許しません。
そのため、大規模なフィールド値を直接格納できません。
大規模なフィールド値を圧縮したり、複数の物理的な行に分割したりすることで、この限界はなくなりました。
これはユーザからは透過的に発生し、また、バックエンドのコード全体には小さな影響しか与えませんでした。
この技法は<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>（または<SPAN
CLASS="QUOTE"
>"パンをスライスして以来最善のもの"</SPAN
>）という愛称で呼ばれます。
[訳注：“パンをスライスして以来最善のもの（the best thing since sliced bread）”は素晴らしいものを意味します。]</P
><P
>一部のデータ型のみが<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>をサポートします。
大規模なフィールド値を生成することがないデータ型にオーバーヘッドを負わせる必要はありません。
<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>をサポートするためには、データ型は可変長（<I
CLASS="FIRSTTERM"
>varlena</I
>）表現を持たなければなりません。
格納する値の最初の32ビットワードにはバイト単位の値の（このワード自体を含む）長さが含まれます。
<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>は残りの表現について制限しません。
<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>可能なデータ型をサポートするC言語関数はすべて、<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>化された入力値を注意して扱わなければなりません
（通常これは、入力に対して何か作業をする前に<CODE
CLASS="FUNCTION"
>PG_DETOAST_DATUM</CODE
>を呼び出すことで行われますが、もっと効率的な方法が可能な場合もあります）。</P
><P
><ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>はvarlenaの長さワードの2ビット(ビッグエンディアンのマシンでは上位ビット、リトルエンディアンのマシンでは下位ビット)を勝手に使用します。
そのため、すべての<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>可能なデータ型の値の論理サイズは1ギガバイト（2<SUP
>30</SUP
> - 1バイト）までになります。
両ビットが0の場合、値はそのデータ型の普通の<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>化されていない値となり、長さワードの残りのビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
上位側または下位側のどちらか片方のビットが設定された場合、値は通常の4バイトのヘッダを持たず1バイトのヘッダを持ちます。
また、長さワードの残りビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
特殊な状況として、長さワードの残りビットがすべて0（自身の長さを含みますのでありえません）の場合、その値は別のTOASTテーブルに保存される行外データへのポインタです。
（TOASTポインタのサイズはデータの第2バイト内で与えられます。）
単一バイトヘッダを持つ値は特定の境界に整列されません。
最後に上位側または下位側のビットが0で隣のビットが設定されている場合、データの内容は圧縮され、使用前に伸長しなければなりません。
この場合、長さワードの残りビットは元データのサイズではなく圧縮したデータの総サイズになります。
圧縮が行外データでも起こりえますが、varlenaヘッダには圧縮されているかどうかについての情報がないことに注意してください。
その代わりTOASTポインタの内容にこの情報が含まれています。</P
><P
>テーブルの任意の列が<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>可能な場合、そのテーブルは連携する<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>テーブルを持ちます。
<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>テーブルのOIDはテーブルの<TT
CLASS="STRUCTNAME"
>pg_class</TT
>.<TT
CLASS="STRUCTFIELD"
>reltoastrelid</TT
>項目に格納されます。
詳細は後で説明しますが、行外の<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>化された値は<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>テーブル内に保持されます。</P
><P
>使用される圧縮技術は、LZ系の圧縮技術の1つで単純かつ非常に高速なものです。
詳細は<TT
CLASS="FILENAME"
>src/backend/utils/adt/pg_lzcompress.c</TT
>を参照してください。</P
><P
>行外の値は（圧縮される場合は圧縮後に）最大<TT
CLASS="LITERAL"
>TOAST_MAX_CHUNK_SIZE</TT
>バイトの塊に分割されます
（デフォルトではこの値は4チャンク行が1ページに収まり、およそ2000バイトになるように選ばれます）。
各塊は、データを持つテーブルと連携する<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>テーブル内に個別の行として格納されます。
すべての<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>テーブルは<TT
CLASS="STRUCTFIELD"
>chunk_id</TT
>列（特定の<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>化された値を識別するOID）、<TT
CLASS="STRUCTFIELD"
>chunk_seq</TT
>列（値の塊に対する連番）、<TT
CLASS="STRUCTFIELD"
>chunk_data</TT
>（塊の実際のデータ）列を持ちます。
<TT
CLASS="STRUCTFIELD"
>chunk_id</TT
>と<TT
CLASS="STRUCTFIELD"
>chunk_seq</TT
>に対する一意性インデックスは値の抽出を高速化します。
したがって、行外の<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>化された値を示すポインタデータには、検索先となる<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>テーブルのOIDと指定した値のOID(<TT
CLASS="STRUCTFIELD"
>chunk_id</TT
>)を格納しなければなりません。
簡便性のために、ポインタデータには論理データサイズ（元々の非圧縮のデータ長）と実際の格納サイズ（圧縮時には異なります）も格納されます。
varlenaヘッダバイトに収納するために<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>ポインタデータの総サイズは、表現される値の実サイズに関係なく、18バイトになります。</P
><P
><ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>のコードは、テーブル内に格納される値が<TT
CLASS="SYMBOL"
>TOAST_TUPLE_THRESHOLD</TT
>（通常2キロバイト）を超える時にのみ実行されます。
<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>コードは、行の値がより小さくなるかそれ以上の縮小ができなくなるまで、フィールド値の圧縮や行外への移動を行います。
更新操作中、変更されない値は通常そのまま残ります。
行外の値を持つ行の更新では、行外の値の変更がなければ<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>するコストはかかりません。</P
><P
><ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>コードでは、以下の<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>可能な列を格納するための4つの異なる戦略を認めます。

   <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>PLAIN</TT
>は圧縮や行外の格納を防止します。
さらにvarlena型での単一バイトヘッダの使用を無効にします。
これは<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>化不可能のデータ型の列に対してのみ取り得る戦略です。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>EXTENDED</TT
>では、圧縮と行外の格納を許します。
これはほとんどの<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>可能のデータ型のデフォルトです。
圧縮がまず行われ、それでも行が大き過ぎるのであれば行外に格納します。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>EXTERNAL</TT
>は非圧縮の行外格納を許します。
<TT
CLASS="LITERAL"
>EXTERNAL</TT
>を使用すると、<TT
CLASS="TYPE"
>text</TT
>と<TT
CLASS="TYPE"
>bytea</TT
>列全体に対する部分文字列操作が高速化されます。
こうした操作は非圧縮の行外の値から必要な部分を取り出す時に最適化されるためです
（格納領域が増加するという欠点があります）。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>MAIN</TT
>は圧縮を許しますが、行外の格納はできません
（実際にはこうした列についても行外の格納は行われます。
しかし、他に行を縮小させページに合わせる方法がない場合の最後の手段としてのみです）。
     </P
></LI
></UL
><P>

<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>可能なデータ型はそれぞれ、そのデータ型の列用のデフォルトの戦略を指定します。
しかし<TT
CLASS="COMMAND"
>ALTER TABLE SET STORAGE</TT
>を使用して、あるテーブル列の戦略を変更することができます。</P
><P
>この機構には、ページをまたがる行の値を許可するといった素直な手法に比べて多くの利点があります。
通常問い合わせは比較的小さなキー値に対する比較で条件付けされるものと仮定すると、エクゼキュータの仕事のほとんどは主だった行の項目を使用して行われることになります。
<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>化属性の大規模な値は、（それが選択されている時）結果集合をクライアントに戻す時に引き出されるだけです。
このため、主テーブルは行外の格納を使用しない場合に比べて、かなり小さくなり、その行は共有バッファキャッシュにより合うようになります。
ソート集合もまた小さくなり、ソートが完全にメモリ内で行われる頻度が高くなります。
小規模な試験結果ですが、典型的なHTMLページとそのURLを持つテーブルでは、<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>テーブルを含め、元々のデータサイズのおよそ半分で格納でき、さらに、主テーブルには全体のデータのおよそ10%のみ（URLと一部の小さなHTMLページ）が格納されました。
TOAST化されないようにすべてのHTMLページを7キロバイト程度に切り詰めてた<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>かつ圧縮化しないテーブルと比べ、実行時に違いはありませんでした。</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="storage-file-layout.html"
ACCESSKEY="P"
>&#21069;&#12398;&#12506;&#12540;&#12472;</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>&#12507;&#12540;&#12512;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="storage-fsm.html"
ACCESSKEY="N"
>&#27425;&#12398;&#12506;&#12540;&#12472;</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>データベースファイルのレイアウト</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="storage.html"
ACCESSKEY="U"
>&#19978;&#12395;&#25147;&#12427;</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>空き領域マップ</TD
></TR
></TABLE
></DIV
></BODY
></HTML
></div>
